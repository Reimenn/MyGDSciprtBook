<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".\.\mdbook-admonish.css">
        <link rel="stylesheet" href="src/css/style.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="GDScript.html">GDScript 零基础图文入门</a></li><li class="chapter-item expanded "><a href="ABOUT.html"><strong aria-hidden="true">1.</strong> 关于本文</a></li><li class="chapter-item expanded "><a href="Part1/Start.html"><strong aria-hidden="true">2.</strong> 开始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part1/什么是编程.html"><strong aria-hidden="true">2.1.</strong> 什么是编程</a></li><li class="chapter-item expanded "><a href="Part1/第一句代码.html"><strong aria-hidden="true">2.2.</strong> 第一句代码</a></li><li class="chapter-item expanded "><a href="Part1/脚本结构.html"><strong aria-hidden="true">2.3.</strong> 脚本结构</a></li><li class="chapter-item expanded "><a href="Part1/后续预告.html"><strong aria-hidden="true">2.4.</strong> 后续预告</a></li></ol></li><li class="chapter-item expanded "><a href="Part2/Start.html"><strong aria-hidden="true">3.</strong> 基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part2/变量.html"><strong aria-hidden="true">3.1.</strong> 变量</a></li><li class="chapter-item expanded "><a href="Part2/数据类型.html"><strong aria-hidden="true">3.2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="Part2/表达式与运算符.html"><strong aria-hidden="true">3.3.</strong> 表达式与运算符</a></li><li class="chapter-item expanded "><a href="Part2/整活：你好XXX.html"><strong aria-hidden="true">3.4.</strong> 整活：你好XXX</a></li><li class="chapter-item expanded "><a href="Part2/代码块.html"><strong aria-hidden="true">3.5.</strong> 代码块</a></li><li class="chapter-item expanded "><a href="Part2/分支结构.html"><strong aria-hidden="true">3.6.</strong> 分支结构</a></li><li class="chapter-item expanded "><a href="Part2/作用域.html"><strong aria-hidden="true">3.7.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="Part2/整活：狐狸彩票.html"><strong aria-hidden="true">3.8.</strong> 整活：狐狸彩票</a></li><li class="chapter-item expanded "><a href="Part2/循环.html"><strong aria-hidden="true">3.9.</strong> 循环</a></li><li class="chapter-item expanded "><a href="Part2/数组.html"><strong aria-hidden="true">3.10.</strong> 数组</a></li><li class="chapter-item expanded "><a href="Part2/遍历.html"><strong aria-hidden="true">3.11.</strong> 遍历</a></li><li class="chapter-item expanded "><a href="Part2/循环控制.html"><strong aria-hidden="true">3.12.</strong> 循环控制</a></li></ol></li><li class="chapter-item expanded "><a href="Part-认识面向对象/Start.html"><strong aria-hidden="true">4.</strong> 认识面向对象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-认识面向对象/方法.html"><strong aria-hidden="true">4.1.</strong> 方法</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/方法参数.html"><strong aria-hidden="true">4.2.</strong> 方法-参数</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/方法返回值.html"><strong aria-hidden="true">4.3.</strong> 方法-返回值</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/面向对象.html"><strong aria-hidden="true">4.4.</strong> 面向对象</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/类.html"><strong aria-hidden="true">4.5.</strong> 类</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/类成员.html"><strong aria-hidden="true">4.6.</strong> 类成员</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/日后再深入.html"><strong aria-hidden="true">4.7.</strong> 日后再深入</a></li></ol></li><li class="chapter-item expanded "><a href="Part-引擎交互/Start.html"><strong aria-hidden="true">5.</strong> 引擎交互</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-引擎交互/生命周期1.html"><strong aria-hidden="true">5.1.</strong> 生命周期1</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/生命周期2.html"><strong aria-hidden="true">5.2.</strong> 生命周期2</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/获取输入.html"><strong aria-hidden="true">5.3.</strong> 获取输入</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/线性输入.html"><strong aria-hidden="true">5.4.</strong> 线性输入</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> 整活：玩家移动</div></li><li class="chapter-item expanded "><a href="Part-引擎交互/PackedScene实例化.html"><strong aria-hidden="true">5.6.</strong> PackedScene实例化</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/节点操作.html"><strong aria-hidden="true">5.7.</strong> 节点操作</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> 整活：Fire</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> 碰撞检测</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> 组</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> 节点锁定</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> 整活：靶子</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> 整活：分数</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> 射线检测</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> 整活：敌人</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 深入面向对象</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> 定义类</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> 类的使用</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> 封装</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> 类型注解</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> 整活：玩家生命值和基础UI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> 继承</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.7.</strong> 重写</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.8.</strong> 多态</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.9.</strong> 枚举</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.10.</strong> 整活：多种武器</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.11.</strong> 信号</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.12.</strong> 单例/自动加载</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.13.</strong> 整活：更换武器的UI提示</div></li></ol></li><li class="chapter-item expanded "><a href="待整理的内容.html"><strong aria-hidden="true">7.</strong> 还没整理的内容</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Reimenn/MyGDSciprtBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gdscript-零基础图文入门"><a class="header" href="#gdscript-零基础图文入门">GDScript 零基础图文入门</a></h1>
<p>各位热爱游戏的小伙伴们大家好。</p>
<p>随着 Godot 的热度越来越高，有很多无程序开发基础的小伙伴认识了 Godot，个人认为 Godot 从 4.0 版本开始，已经成为了最适合游戏开发新人上手的引擎（易上手 不等于 功能简单），她相较于 Unity 更易学习，且功能足够各位开发者实现自己的梦中游戏。</p>
<p>开发游戏通常离不开编写代码，Godot 支持的编程语言中 <code>GDScript</code> 和 <code>C#</code> 是使用最广泛的：</p>
<ul>
<li>
<p><code>C#</code> 是微软公司开发的编程语言，虽然普及率不如 <code>Java</code>、<code>Python</code> 等“超一线”语言，但其功能十分强大，且拥有“宇宙第一优雅”的编程语法，但由于它真的很强大且语法实在“优雅”，学习它会花费更多的时间与精力。</p>
</li>
<li>
<p>而 <code>GDScript</code> 听名字就知道这是 Godot 自己的编程语言，因为是为游戏开发而设计，语言中的每一项功能都是为了方便我们做游戏而诞生，因此在实现同样功能的情况下，<code>GDScript</code> 会比 <code>C#</code> 少些很多代码，学习起来也更加轻松。</p>
</li>
</ul>
<p>综上所述，我更推荐新人者从 <code>GDScript</code> 上手，这将是一条轻松愉悦的学习路线。</p>
<blockquote>
<p>[!tip] 新人学编程第一大门槛：选择编程语言。</p>
<p>我这里要说：随便选一个语言就行（当然现在我推荐 GDScript 了就不要乱选了233），<strong>重要的是坚持学到最后，不要中途放弃或者换语言</strong>。其实绝大多数编程语言都是共通的，就像你学会合成铁镐子后自然就会合成钻石镐一样，当你通过本文学会 <code>GDScript</code> 后，自然也会看的懂很多其它语言的代码。</p>
</blockquote>
<blockquote>
<p>[!tip] Godot 版本</p>
<p>编写本文时 Godot 刚刚推出了 4.0 rc2，所以文中按照 4.0 版本讲解。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于本文"><a class="header" href="#关于本文">关于本文</a></h1>
<p>以前我在 Gamemaker 那边搞一对一教学来着，最近喜欢上了 Godot，发现这边完善的中文资料少之又少，我结合之前在 gamemaker 那边的教育经验编写本文，希望可以帮助各位。</p>
<hr />
<p>我不是专业写东西的，所以文中肯定会出现问题，如有错误或疑问还请及时反馈，如果真的是本文出了问题，尽早改正可以防止误导更多人。</p>
<hr />
<p>如果你有不懂的地方或者文中没提到但是想学的东西也欢迎联系我，各位的反馈和建议可以让文章更加完善。</p>
<blockquote>
<p>Q: 为什么不录视频教程？</p>
<p>A: 首先视频教程制作太麻烦，其次，我认为通过视频学习东西其实更加费时费力，文档可以随时回头看，视频容易看一遍就自我感觉都会了。</p>
</blockquote>
<blockquote>
<p>整活章节或许可以尝试搞成视频试试，作为本文的补充。</p>
</blockquote>
<hr />
<p>反馈途径</p>
<p>可通过作者 QQ：2293840045 联系我，或者直接使用 git 仓库的 issue 等功能。</p>
<p><em>广告时间：本文作者靠在线一对一教学赚零花钱，如果你想 0 障碍快速学习游戏开发或者其他什么编程知识，欢迎联系我。</em></p>
<blockquote>
<p>本文使用 <a href="https://github.com/rust-lang/mdBook">Mdbook</a> 编写。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>Godot 官网：<a href="https://godotengine.org/">https://godotengine.org/</a></p>
<p>Godot 最新正式版下载：<a href="https://godotengine.org/download/windows/">https://godotengine.org/download/windows/</a></p>
<p>所有版本下载：<a href="https://downloads.tuxfamily.org/godotengine/">https://downloads.tuxfamily.org/godotengine/</a></p>
<p>本文讲解 GDScript，所以下载普通版，就是没有 <code>.NET</code> 或 <code>Mono</code> 字样的版本即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是编程"><a class="header" href="#什么是编程">什么是编程？</a></h1>
<p>编程说白了就是写代码，而代码是控制计算机运行的指令。</p>
<p>对于游戏来讲，游戏中的每一处逻辑都是由代码来控制，游戏的运行离不开代码。</p>
<p>假设要实现<strong>玩家点击空格开火，不点空格回血</strong>这个逻辑，那么就需要写一段这种代码：</p>
<pre><code>游戏中的每一帧都执行：
    如果玩家点了空格：
        开火
    否则（没点空格）：
        给自己加血
</code></pre>
<blockquote>
<p>[!note] 伪代码</p>
<p>上文中这段奇怪的文字被称作<strong>伪代码</strong>，也就是说这并不是真正的程序代码，但是它可以更清晰的表达真实代码的逻辑，通常在设计某些复杂代码之前写出来当草稿用。</p>
</blockquote>
<p>看起来这好像和编程没什么关系，但我没有糊弄你，真正的代码基本就是这个样子：</p>
<pre><code class="language-gdscript">func _process(delta):
    if Input.is_action_just_pressed(&quot;space&quot;):
        fire()
    else:
        hp += 1
</code></pre>
<p>我们学习编程，实际上就是把脑海中的伪代码转换成实际代码，为了完成这个转换工作，首先需要记住一些代码语法，但请注意，代码语法十分简单，这不应该是编程学习中的重点，真正需要你费头脑的是想出那些伪代码，至于语法格式，忘了就翻翻这篇教程，忘多了就会了。</p>
<blockquote>
<p>在 IT 行业工作的程序员中有一种职位专门负责提供思路，也就是“创造伪代码”，那些底层的码农们就负责把“伪代码”翻译成程序语言。（很明显创造伪代码的人工资更高）</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一句代码"><a class="header" href="#第一句代码">第一句代码</a></h1>
<p>如果你就算只碰过一点点编程，应该也会见过这么一句话：</p>
<pre><code class="language-gdscript">&quot;Hello, World!&quot;
</code></pre>
<p>这是计算机行业的元老级 meme 之一，当人们在学习一门新编程语言时，就会想办法让那个语言把上面这几个字母显示在屏幕上。</p>
<p>这时你可以打开 Godot，创建一个 Label，然后在 text 属性中写上 <code>Hello, World!</code>，运行后（或许不用运行）就会看到屏幕上出现了这几个字母，恭喜，你学会 GDScript了！</p>
<p><img src="Part1/./images/create-label-HelloWorld.png" alt="创建HelloWorld标签" /></p>
<p>等等，那说好的代码呢？</p>
<p><del>很明显上面是一些玩笑话</del>，但我建议你还是尝试一编上面的步骤，毕竟你是一位要成为<em>边城带师</em>的人，这种点点鼠标的操作还是要熟练掌握才行的
。</p>
<blockquote>
<p>本文重点在 GDScript，不会涉及太多的引擎操作知识，如果你还不会引擎的基本操作，建议打开 Godot 到处点一点，很快你就会熟悉她的界面逻辑了。</p>
</blockquote>
<blockquote>
<p>给纯新人小伙伴的一个建议：放纵自己的好奇心，对感兴趣的东西先动手尝试再寻求帮助更好。</p>
</blockquote>
<h2 id="print"><a class="header" href="#print">print</a></h2>
<p>下面我来带大家用代码的方式显示一句话。</p>
<p>首先我们要明白 Godot 中构成游戏的基本单位是<code>节点</code>，也就是默认界面左上角的那些东西。我们写的代码被称作<code>脚本</code>（不是玩游戏开挂的那个脚本哈），每个节点可以绑定一个脚本来扩展节点的功能，因此想执行咱自己的代码，第一步就是要有一个节点。</p>
<p>目前随便创建一个节点即可，然后选中节点，点击添加脚本按钮：</p>
<p><img src="Part1/./images/create-node.gif" alt="创建节点并添加脚本" /></p>
<p>在最后出现的窗口中，是对这个新脚本的设置，建议勾上<code>内置脚本</code>选项，其余目前不用改，接着点击<code>创建</code>即可。</p>
<p>接着咱就被带到了一个代码编辑器中，看起来应该是这样：</p>
<pre><code class="language-gdscript">extends Control

# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	pass
</code></pre>
<blockquote>
<p>第一行可能不太一样，这取决于刚刚创建的节点是什么类型。</p>
</blockquote>
<p>现在目标聚焦 <code>func _ready():</code> 这一行，在这一行的最后咱们加一个回车，然后输入 <code>print(&quot;Hello, World!&quot;)</code>，完事后这一段应该是下面这个样子：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;Hello, World!&quot;)
    pass
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>注意不要改动其他地方的代码，上面我放了三行代码只是完整代码的一部分，因为每次都贴完整代码太长了，所以我就省略了其他部分，但你不要省略。</p>
</blockquote>
<p>注意 <code>print</code> 的前面应该是一个制表符，Godot 应该会自动帮你加上，如果你发现 <code>print</code> 和下面的 <code>pass</code> 没有垂直对齐，可能需要手动在前面输入一个制表符（按Tab键输入）。</p>
<p>接下来，保存场景、运行游戏，发动你的火眼金晶在屏幕上找到 <code>Hello, World!</code> 吧！</p>
<p><img src="Part1/./images/helloWorld.png" alt="helloWorld" /></p>
<p>恭喜你已经成功运行了第一句 GDScript 代码！</p>
<blockquote>
<p>[!warning] 常见问题</p>
<ol>
<li>
<p>在编程时我们要保证自己的输入法处于英文状态，一般的编程语言不认识中文符号，看看你 print 后面的括号和双引号是英文的吗？</p>
</li>
<li>
<p><code>Hello, World!</code> 两边的双引号在这里表示<strong>中间夹着一段文字</strong>，因此不要省略这俩双引号！</p>
</li>
<li>
<p>运行的场景要选择当前编写代码的场景，不要运行错了场景。（可以点击F6直接运行当前场景）</p>
</li>
</ol>
<p>... 更多问题等待你的反馈，我会在这里解答</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p>print 这句话的功能其实就是在 Godot 引擎界面中显示一些东西，虽然玩家看不到，但对于我们开发者来讲通常会利用 print 进行一些排错工作，起到类似于日志的作用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="脚本结构"><a class="header" href="#脚本结构">脚本结构</a></h1>
<p>上一节咱们运行了一句代码，但我估计你应该还是比较蒙，这节就来看一下之前那篇代码的每一句话是什么意思。</p>
<h2 id="代码语法之注释"><a class="header" href="#代码语法之注释">代码语法之：注释</a></h2>
<p>首先来认识一个最简单的语法，它叫做<code>注释</code>。</p>
<p>因为代码本质上还是给计算机看的东西，在逻辑复杂或代码太长时，人类阅读起来非常困难，人们就在代码中穿插加入一些小笔记来解释代码的逻辑和用法，这种小笔记就是注释了。</p>
<p>在 GDScript 中输入一个井号 <code>#</code> 就表示注释，从这个符号开始到这一行结束都属于注释范围，所以再来之前那篇代码，就会发现其中很多东西都是注释（方便理解，我把注释翻译成了中文）：</p>
<pre><code class="language-gdscript">extends Control

# 在节点第一次进入场景树时执行
func _ready():
	pass # 用方法体替换这里

# 每一帧执行一次，'delta' 指上一帧和这一帧的间隔时间
func _process(delta):
	pass
</code></pre>
<p>可以看到，Godot 还贴心的留给了我们三句话。。。</p>
<blockquote>
<p>[!tip]</p>
<p>注释不会被当作代码执行，如果你给刚才的 print 前面加上 # 号，那么 print 就不会执行了，所以有时遇到了某段代码不确定要不要删除，也可以先用注释的方式临时屏蔽。（虽然规范上不建议这样做，但是一个人开发的情况下老子就是规范）</p>
</blockquote>
<h2 id="代码语法之方法"><a class="header" href="#代码语法之方法">代码语法之：方法</a></h2>
<p><strong>方法</strong>这个名称实在是抽象，它还有另一个名称叫做<strong>函数</strong>，行吧，也比较抽象。。。</p>
<p>你可以把方法理解成一段保存好的代码，在需要执行的时候<strong>调用</strong>一下就会执行。</p>
<p>GDScript 中使用 <code>func</code> 表示一个方法，后面紧跟一个方法的名字，所以再看上面的代码，我们会发现其中包含两个方法，分别是<code>_ready</code>和<code>_process</code>。</p>
<p>方法的最后有一个冒号，然后另起一行的内容就是<strong>方法体</strong>，也就是这个方法所包含的代码， <code>pass</code> 关键字表示这个方法没有代码，也可以把 <code>pass</code> 替换成咱自己的代码。</p>
<blockquote>
<p>之前写的 print 下面还跟着一个 pass 呢，那个 pass 其实没用，删掉也可以。</p>
</blockquote>
<blockquote>
<p>方法和函数这两个名字我也经常混着用，如果看到后面发现我提到了函数这个词，要知道指的就是方法。</p>
</blockquote>
<p>结合官方给的注释，现在我们大致明白之前的 print 代码是怎么回事了，因为咱把 print 放在了 <code>_ready</code> 方法当中，按照注释“在节点第一次进入场景树时执行”所说，咱们的 print 就跟着 <code>_ready</code> 在节点第一次出现时执行了一次。</p>
<blockquote>
<p>[!tip] 还是有点蒙吗？</p>
<p>这一节的内容留个印象即可，后面会再详细讲解，现在只需要知道两件事：</p>
<ol>
<li>
<p><code>_ready</code> 方法中的代码会游戏刚运行时执行</p>
</li>
<li>
<p><code>_process</code> 方法中的代码会在游戏运行时的每一帧执行</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>[!tip] 啥叫场景树？</p>
<p>Godot 中把一堆节点构成的东西称作<strong>树</strong>，那么场景树就是这个场景中节点所组成的树了。</p>
<p>至于<strong>进入</strong>场景树就是指<strong>加入</strong>到场景树中，也就是游戏刚开始时了。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后续预告"><a class="header" href="#后续预告">后续预告</a></h1>
<div style="width:40%;margin: 4em auto;border:0.4em dashed #ffffff55;padding:1em">
到这里，你就没有回头路了
<div style="text-align:right">-- 沃夏·硕德</div>
</div>
<hr />
<p>为了保证学习不枯燥，后续教程中会穿插一些实践内容，这些小节标题以<code>整活</code>开头，各位小伙伴也可以整自己的活，本文整活仅供参考，大家要发挥自己的想象力。</p>
<p>下一节将重点讲解 GDScript 的基础语法，这里包含很多代码逻辑相关的知识。</p>
<p>再下一节重点讲解面向对象思想，这是一种目前最流行的程序设计方式，Godot 也是完全在这套思想下运行的。</p>
<p>这两节就会把 GDScript 的语法都介绍完毕，后续内容则是 Godot 引擎本身的各种功能使用方式介绍。</p>
<blockquote>
<p>最后，提醒各位新人，学习 Godot 要主动自学，这并不是因为 “Godot 资料少”一类原因造成的，因为每个人的心中都有属于自己的游戏，他人的教程终究不能完全覆盖你需要的知识。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<p>GDScript 是一门十分像 Python 的语言，但针对游戏进行了很多优化。</p>
<p>本章讲解基础语法，略微涉及一些实践内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>变量是代码中用来存放数据的基本单位（抛开计算机底层不谈），游戏中会变的量都是变量。</p>
<p>玩家的生命值、游戏分数这种直观看到的数字是变量，玩家的位置、任务进度这种抽象的数据也是变量。</p>
<p>在 GDScript 中使用 <code>var</code> 关键字声明一个变量，它的基本语法格式如下：</p>
<pre><code class="language-gdscript">var &lt;变量名&gt; [= &lt;变量值&gt;]
</code></pre>
<p>比如咱们要存放玩家的生命值，咱就可以写一句 <code>var 生命值 = 100</code>，这就声明了一个叫做<code>生命值</code>的变量，其中存放的数据是 100。</p>
<blockquote>
<p>[!tip] 语法格式解读</p>
<p>本文中使用上面这种格式展示语法，其中<code>尖括号</code>引用的内容表示必须填写，并把尖括号内的东西换成改填入的字符，例如<code>&lt;变量名&gt;</code>就表示这里必须要写一个变量名，至于名字是什么你可以自己来定。</p>
<p>方括号表示可选填写，var 语句后面的初始值其实是可以省略不写的，不过一般不会这样做。</p>
</blockquote>
<h2 id="变量声明的位置"><a class="header" href="#变量声明的位置">变量声明的位置</a></h2>
<p>这句 var 开头的代码可以放到方法体中，也可以放到方法体的外面：</p>
<pre><code class="language-gdscript">var 生命值 = 100 # 放在了 _ready 的外面
func _ready():
	var 生命值 = 100 # 放在了 _ready 的里面
</code></pre>
<p>当放在方法外面，也就是文件最外层时，表示这个变量属于当前节点，也就是说这个节点现在拥有了<code>生命值</code>这个属性，这个变量随着节点一起出现和消失。</p>
<p>当放在方法里面时，这个变量就成了一个临时变量，当方法被执行，程序运行到 var 语句这一行时就会创建这个变量，当方法执行完毕时，这个变量就会自动消失。</p>
<p>因此可以感觉到，如果要处理一个持续的数据，应该把变量的声明放在方法的外面。</p>
<h2 id="变量赋值"><a class="header" href="#变量赋值">变量赋值</a></h2>
<p>现在假设咱们给节点声明了<code>生命值</code>这个变量，现在希望它每帧扣除一滴血，这时就可以使用变量赋值语句来修改变量的值，赋值语句格式如下：</p>
<pre><code class="language-gdscript">&lt;变量名&gt; = &lt;新的值&gt;
</code></pre>
<p>可见其实就是把 var 关键字去掉了而已，既然这样，实现扣除一滴血的代码就可以这样写：</p>
<pre><code class="language-gdscript">func _process(delta):
    生命值 = 生命值 - 1
</code></pre>
<p>由于 _process 是每帧执行一次，所以上面代码就实现了每帧扣除一点血。</p>
<blockquote>
<p>注意不要在前面加上 var，否则就成了每帧声明一个新变量。</p>
</blockquote>
<blockquote>
<p>[!tip] 什么是关键字</p>
<p>关键字就是指 GDScript 中具有特殊含义的一些单词，例如 var，他就表示创建变量。</p>
</blockquote>
<blockquote>
<p>[!tip] 中文变量名</p>
<p>Godot 从 4.0 beta 1x 的某个版本开始支持中文变量名，但大多数人更喜欢英文变量名，本文为了阅读方便考虑（我怕我英语渣闹笑话）采用汉字变量名。</p>
</blockquote>
<blockquote>
<p>[!tip] 声明？创建？</p>
<p>在 生命值 这个例子中声明就等于创建，但不要和后面要学到的创建（实例化）对象搞混。</p>
</blockquote>
<blockquote>
<p>[!note] 变量名命名规则</p>
<p>上面提到了，变量名是自己起的，但很明显不能乱起，例如我让一个变量叫 var，这肯定很怪，所以变量名有以下规则：</p>
<ul>
<li>
<p>不能使用数字开头</p>
</li>
<li>
<p>不能包含特殊字符，例如空格、加号等（唯一支持的符号是下划线 _）</p>
</li>
<li>
<p>不能换关键字重复（例如 var）</p>
</li>
</ul>
<p>本文为了阅读方便，将尽量使用中文命名，这样读者可以根据变量名快速区分 Godot 内置变量和我们定义的变量，不过在一般的开发中，变量名还是以英文为主。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>对于人类来讲，看到 <code>5</code> 就知道这是数字，看到 <code>Hello</code> 就知道这是单词，那么<strong>数字</strong>和<strong>单词</strong>这种概念在计算机中就被称为数据类型。</p>
<p>GDScript 中的基本数据类型有这些：</p>
<ul>
<li><strong>整数</strong>，例如 <code>100</code> <code>10</code> <code>0</code> 都是整数</li>
<li><strong>小数</strong>，例如 <code>3.14</code> <code>0.1</code> <code>0.0</code> <code>4.0</code> 都是小数</li>
<li><strong>字符串</strong>，与双引号或单引号包裹的内容是字符串，例如 <code>&quot;Hello, World!&quot;</code> <code>&quot;我是字符串&quot;</code> 都是字符串</li>
<li><strong>布尔值</strong>，这种类型表示真假或对错，只有 <code>true</code> 和 <code>false</code> 这两个值，对应 <code>真</code> 和 <code>假</code></li>
</ul>
<p>下面是使用时的例子：</p>
<pre><code class="language-gdscript">var hp      = 100
var pos     = 4.2
var name    = &quot;Rika&quot;
var walking = false
</code></pre>
<blockquote>
<p>[!tip] 代码格式</p>
<p>实际上变量名后面可以不写空格直接跟上等于号，我为了美观让这些等于号垂直对齐了，实际开发中根据自己喜好加空格即可。</p>
<p>不过，通常的编码规范都要求能加空格的地方至少加一个空格，毕竟密麻麻的字母看起来容易眼花。</p>
<p>其实大部分代码编辑器都有自动格式化代码的功能，可以一键美化代码，可惜目前的 Godot 还不支持（截止 4.0 rc2）</p>
</blockquote>
<h2 id="数据类型转换自动"><a class="header" href="#数据类型转换自动">数据类型转换（自动）</a></h2>
<p>我们看一段代码：</p>
<pre><code class="language-gdscript">var a = 10
var b = 3.14
var c = a + b
</code></pre>
<p>首先我们定义了一个变量 a，它存放整数 10，又定义变量 b，存放小数 3.14，最后定义变量 c 存放 a 与 b 的和，那么问题来了，变量 c 中存放了一个什么类型的数字呢？</p>
<p><code>a + b</code> 这个式子是 <code>整数 + 小数</code> 的形式，为了能够正确的到 13.14 这个数，他的结果显然是小数类型。</p>
<p>虽然整数参与了运算，但结果是小数，也就是说这其中自动进行了数据类型的转换，不过因为是自动进行的，所以我们通常不用在意。</p>
<blockquote>
<p>这种自动类型转换在不同语言中有不同的名字，例如有的叫 <strong>隐式类型转换</strong>，有的叫 <strong>自动类型提升</strong>，这东西和计算机存储数据的原理有关，在这里就不过多讨论了。</p>
</blockquote>
<h2 id="为什么需要数据类型转换"><a class="header" href="#为什么需要数据类型转换">为什么需要数据类型转换？</a></h2>
<p>我们再看一段代码：</p>
<pre><code class="language-gdscript">print(10 / 3)
</code></pre>
<p>思考，这会显示什么呢？</p>
<p>按道理讲这应该会显示 3.一堆3，但实际我们只能看到一个数字 3，这是因为这个 <code>10 / 3</code> 是整数运算，这种情况下得到的结果也必定是整数，因此就看不到小数点后面的内容了。</p>
<p>这时我们可以手动修改一下：</p>
<pre><code class="language-gdscript">print(10 / 3.0)
</code></pre>
<p>对于 GDScript 来说，只要数字包含小数点，即便小数位全是 0，这个数也是小数类型，所以修改后的 print 就能正常显示 3.一堆3 了。并且这其中还对整数 10 进行了自动类型转换。</p>
<blockquote>
<p>计算机存储空间有限，小数位数肯定也有限，实际显示的是 <code>3.33333333333333</code>，不会特别长。</p>
</blockquote>
<blockquote>
<p>如果想要运行看看效果，记得把这些代码都放到 <code>_ready():</code> 这个方法体中再运行游戏。</p>
</blockquote>
<h2 id="数据类型转换手动"><a class="header" href="#数据类型转换手动">数据类型转换（手动）</a></h2>
<p>有自动类型转换，肯定也就有手动类型转换了，现在把刚刚的 <code>10 / 3</code> 代码稍作修改：</p>
<pre><code class="language-gdscript">var a = 10
var b = 3
print(a / b)
</code></pre>
<p>这个的结果大家已经知道，就是 3，现在假设，变量 a 和 b 是从其他地方获取的值，这个值就是整数，不能通过添加小数点的方式让它变成小数。</p>
<p>于是需要我们手动进行类型转换了，它的语法格式如下：</p>
<pre><code>&lt;目标类型&gt;(&lt;被转换的值&gt;)
</code></pre>
<p>其中目标类型可选如下：</p>
<ul>
<li><code>int</code> - 整数</li>
<li><code>float</code> - 小数</li>
<li><code>bool</code> - 布尔值</li>
</ul>
<p>我们需要把整数变成小数，所以目标类型就是 <code>float</code>，接着来修改 <code>print</code> 这一行：</p>
<pre><code class="language-gdscript">print(float(a) / float(b)) # 只给一个变量加上 float 也行，另一个会自动转换类型
</code></pre>
<p>接着就能再次看到 3.一堆3 了。</p>
<blockquote>
<p>[!tip] 四舍五入</p>
<p><code>int(1.9)</code> 的结果是 1，也就是直接抛弃小数，如果想要四舍五入取整，可以改成 <code>round(1.9)</code>，这样结果就是 2 了。</p>
</blockquote>
<blockquote>
<p>[!tip] 函数调用</p>
<p>你应该已经发现，<code>float(XXX)</code> 这种东西和 <code>print(XXX)</code> 的格式一摸一样，这种格式被称为<strong>方法调用</strong>，在后面方法章节会单独讲解。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式与运算符"><a class="header" href="#表达式与运算符">表达式与运算符</a></h1>
<p>表达式是由一些值和运算符组成的式子，例如 <code>10 + 2</code> 这种。</p>
<p>GDScript 中表达式分为这么几类：</p>
<ul>
<li>算数表达式</li>
<li>关系表达式</li>
<li>逻辑表达式</li>
<li>赋值表达式</li>
</ul>
<h2 id="算术表达式"><a class="header" href="#算术表达式">算术表达式</a></h2>
<p>顾名思义，算是表达式就是指数学运算的式子，例如 <code>5 + 2</code> <code>100 * 0.5</code> 等，运算符有这些：</p>
<ul>
<li><code>+</code> 加</li>
<li><code>-</code> 减</li>
<li><code>*</code> 乘</li>
<li><code>/</code> 除</li>
<li><code>%</code> 求余（取模）</li>
</ul>
<p>最后一个取余数可能有点忘了是什么，其实就是小学二年级还没学小数的时候，“两个数除不尽”剩下的那个数，例如：</p>
<pre><code class="language-gdscript">print(10 % 3) # 显示 1，因为 10 / 3 商 3 余 1
print(15 % 5) # 显示 0，因为 15 / 5 商 5，正好除尽
</code></pre>
<p>同时不要忘记先算乘除后算加减，必要时使用括号改变运算顺序：</p>
<pre><code class="language-gdscript">((10 + 4) * 2 - 8) * 2
</code></pre>
<p>不要轻视这个小学知识点，在修改代码时可能会忘记前后的符号导致运算优先级出错，这种 bug 找起来十分麻烦。</p>
<blockquote>
<p>[!tip] % 的优先级</p>
<p>是先求余还是先加减乘除？哈哈，我不告诉你。</p>
<p>当你的式子很长时，建议用一个临时变量保存一下中间结果，保证编程思路的清晰比什么都重要。</p>
<p>如果真的要在式子里混合求余运算符呢？那就加括号呗。</p>
<p>（<del>我写了七八年代码也没记住 % 的优先级，毕竟没有必要记住</del>）</p>
</blockquote>
<blockquote>
<p>[!tip] 负数</p>
<p>直接在数字或变量前加一个减号即可表示负数，例如 <code>print(-10)</code>，或是先 <code>var a = 1</code> 再 <code>print(-a)</code> 即可显示 <code>-1</code></p>
</blockquote>
<blockquote>
<p>[!note] 字符串拼接</p>
<p>加号 + 的两侧若为字符串，还表示字符串拼接，例如 <code>var a = &quot;a&quot; + &quot;b&quot;</code>，那么 a 里面就会存放 <code>ab</code> 这两个字符。</p>
</blockquote>
<h2 id="关系表达式"><a class="header" href="#关系表达式">关系表达式</a></h2>
<p>关系表达式的运算符如下：</p>
<ul>
<li><code>&gt;</code> 大于</li>
<li><code>&lt;</code> 小于</li>
<li><code>&gt;=</code> 大于等于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>==</code> 等于</li>
<li><code>!=</code> 不等于</li>
</ul>
<p>这些应该也没什么好讲的，那么看一句代码：</p>
<pre><code class="language-gdscript">print(10 &gt; 9)
</code></pre>
<p>嗯，很简单，可是......它会显示什么呢？</p>
<p>这时要了解关系表达式的一个特点：它的结果是布尔值，也就是 true 或 false。</p>
<p>因为 <code>10 &gt; 9</code> 这是个正确的不等式，所以结果是 true，假如有一句 <code>print(10 == 9)</code>，那么这就会显示 <code>false</code> 了。</p>
<h2 id="逻辑表达式"><a class="header" href="#逻辑表达式">逻辑表达式</a></h2>
<p>逻辑表达式的运算符有这些：</p>
<ul>
<li><code>not</code> 非（否）</li>
<li><code>and</code> 与（同时为 true）</li>
<li><code>or</code> 或（任意为 true）</li>
</ul>
<p>乍一看比较蒙，根据括号里的词语理解一下，这三个运算符是对布尔值进行计算的。</p>
<p>第一个 <code>not</code> 是一个一元运算符，它只对一个数据进行操作，写在被操作数的前面，例如 <code>not false</code> 就表示 <code>true</code>。</p>
<p><code>and</code> 运算符只有在两侧都为 <code>true</code> 时结果才是 <code>true</code>，否则结果一律为 <code>false</code></p>
<p><code>or</code> 与 <code>and</code> 相反，两侧都为 <code>false</code> 结果才是 <code>false</code>，否则结果为 <code>true</code>。或者理解成只要有一个 <code>true</code>，结果就是 <code>true</code>。</p>
<h2 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h2>
<p>我们一直看到的等于号 <code>=</code> 其实就是一个赋值运算符，它的作用就是把右边的值放到左边的变量中。</p>
<p>其他的常用赋值运算符还有 <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code>，他们分别表示根据变量中原有的值进行相对运算并保存到变量中，例如：</p>
<pre><code class="language-gdscript">var a = 10
a += 10  # a 在原来的基础上又加了10，变成了20
a *= 2   # 由于上一句代码，a已经是20了，再乘上2，就变成了40
a /= 10  # 40 / 10 得到 4，a变成了4
print(a) # 显示 4
</code></pre>
<h2 id="多种运算符混合计算"><a class="header" href="#多种运算符混合计算">多种运算符混合计算</a></h2>
<p>我们貌似已经发现了规律：</p>
<ul>
<li>数学运算符的参数是数字，结果是数字</li>
<li>关系运算符的参数是数字，结果是布尔值</li>
<li>逻辑运算符的参数是布尔值，结果是布尔值</li>
</ul>
<p>所以，当上述多种运算符组合在一起时，会先运算数学运算符，接着是关系运算符，然后运行逻辑运算符，当然最后是赋值运算符。</p>
<blockquote>
<p>[!tip] 等于和不等于</p>
<p><code>==</code> 和 <code>!=</code> 两侧的值不一定是数字，例如 <code>&quot;Abc&quot; == &quot;Abc&quot;</code> 的结果是 <code>true</code>，<code>&quot;123&quot; == 123</code> 的结果是 <code>false</code>。</p>
</blockquote>
<h2 id="综合例子"><a class="header" href="#综合例子">综合例子</a></h2>
<p>现在来测一测自己，下面这段代码的每个 print 会显示什么？</p>
<pre><code class="language-gdscript">print(5 - 3 &lt; 10)
var a = 100
print(a &gt;= 100 and false)
a -= 99
a *= 10
print(a + 10)
</code></pre>
<p>答案在下面</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<blockquote>
<p>true</p>
<p>false</p>
<p>20</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活你好xxx"><a class="header" href="#整活你好xxx">整活：你好XXX</a></h1>
<p>经历了枯燥的变量、数据类型、运算符的学习，欢迎来到第一个整活章节。</p>
<p>哈哈，也不要以为整活章节就不用学东西了，毕竟想一想，就目前学的 GDScript 能整什么活呢？</p>
<p>所以在整活章节中，我们需要学习 GDScript 操作 Godot 游戏的方法，这一节咱们实现这样一个功能：</p>
<p><img src="Part2/./images/hello.gif" alt="Hello" /></p>
<p>这里有一个按钮和一个输入框，点击按钮后，按钮上就会显示 <code>你好：&lt;输入的内容&gt;</code> 这句问候。</p>
<h2 id="场景创建"><a class="header" href="#场景创建">场景创建</a></h2>
<p>场景很简单，共有三个节点：</p>
<p><img src="Part2/./images/hello_tree.png" alt="Tree" /></p>
<p>添加好后调整它们的位置即可，怎么摆放大家随心即可。</p>
<p>接下来给最外层的 Control 节点添加一个内置脚本，暂时不需要修改里面的内容。</p>
<p>然后关键步骤来了，选中按钮，接着点击引擎右边的 <code>节点</code> 选项卡，进入 <code>信号</code> 列表，找到其中的 <code>pressed()</code> 并双击：</p>
<p><img src="Part2/./images/connect_button_pressed_1.png" alt="双击信号" /></p>
<p>然后就会看到一个弹窗，在窗口中选中添加了脚本的 Control 节点并点击连接</p>
<p><img src="Part2/./images/connect_button_pressed_2.png" alt="连接信号" /></p>
<p>然后我们的脚本中就会多出一个 <code>_on_button_pressed</code> 方法，应该长这样：</p>
<pre><code class="language-gdscript">func _on_button_pressed():
	pass # Replace with function body.
</code></pre>
<h2 id="解读"><a class="header" href="#解读">解读</a></h2>
<p>当按钮被点击时，就会发出 <code>pressed</code> 信号，而现在按钮的 <code>pressed</code> 信号连接了脚本中的 <code>_on_button_pressed</code> 方法，就意味着点击按钮就会执行这个方法，你可以在方法中先写一句 print 试试。</p>
<h2 id="获取节点"><a class="header" href="#获取节点">获取节点</a></h2>
<p>既然要获取输入内容，就要先找到输入框节点，获取节点的语法是这样的：</p>
<pre><code>$&lt;节点路径&gt;
</code></pre>
<p>目前输入框的节点路径就是他的名字，所以咱可以在 <code>_on_button_pressed</code> 方法中写下：</p>
<pre><code class="language-gdscript">var 输入框 = $LineEdit
var 按钮 = $Button # 顺手把按钮也拿到
</code></pre>
<h2 id="获取节点属性"><a class="header" href="#获取节点属性">获取节点属性</a></h2>
<p>输入框节点的 text 属性表示输入的值，通过一个小数点的点 <code>.</code>，可以从节点中获取属性，所以：</p>
<pre><code class="language-gdscript">var 输入值 = 输入框.text
</code></pre>
<p>按钮的显示文字也是 text 属性控制的，所以把这个输入值加上前缀，再交给按钮的 text 就完成这节整活了。</p>
<pre><code class="language-gdscript">按钮.text = &quot;你好：&quot; + 输入值
</code></pre>
<p>最终的完整方法应该长这样：</p>
<pre><code class="language-gdscript">func _on_button_pressed():
	var 输入框 = $LineEdit
	var 按钮 = $Button # 顺手把按钮也拿到
	var 输入值 = 输入框.text
	按钮.text = &quot;你好：&quot; + 输入值
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码块"><a class="header" href="#代码块">代码块</a></h1>
<p>之前我们简单介绍了一下代码块概念，这里再复习一下。</p>
<p>代码块就是指一片代码的集合，通常使用一个冒号 <code>:</code> 开头，然后使用相同的缩进表示，某些其他语法需要由代码块来组成。</p>
<p>例如方法：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;我是代码块里第一行代码&quot;)
    print(&quot;我是代码块里第二行代码&quot;)
</code></pre>
<p>现在假设有一个 print 向右缩进了一点：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;我是代码块里第一行代码&quot;)
        print(&quot;这一行会出错&quot;)
</code></pre>
<p>由于第二个 print 缩进和上面不一致，那么这个 print 就不属于方法的代码块了。</p>
<p>同理，向左缩进也一样。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分支结构"><a class="header" href="#分支结构">分支结构</a></h1>
<p>我们之前写的代码其实并没有什么逻辑可言，它们只会按照顺序一行行执行而已。</p>
<p>在真正的游戏中有很多<strong>分支</strong>，例如玩家与 NPC 对话时，如果完成了任务，NPC 就会给玩家奖励，否则 NPC 就会告诉玩家一些任务提示。这里的<strong>任务是否完成</strong>就是一个分支条件。</p>
<h2 id="如果"><a class="header" href="#如果">如果</a></h2>
<p>在程序中使用关键字 <code>if</code> 来表示分支，它的语法格式如下：</p>
<pre><code>if &lt;逻辑表达式&gt; :
    &lt;代码块&gt;
</code></pre>
<p>if 可以直接理解成汉语中的<strong>如果</strong>，当逻辑表达式的值为 <code>true</code> 时就会执行下面的代码块，否则就不执行。</p>
<p>其中的逻辑表达式就是指一条运算结果为逻辑值的式子，现在假设咱有个变量 <code>var 任务完成数 = 10</code> 来表示当前完成了几个任务，当完成 20 个任务时显示恭喜通关：</p>
<pre><code class="language-gdscript">func _ready():
    var 任务完成数 = 10
    if 任务完成数 &gt;= 20:
        print(&quot;恭喜通关了&quot;)
</code></pre>
<p>目前运行游戏的话你会发现什么也没有显示，毕竟<code>任务完成数</code>现在是10，if 后面的条件不满足，也就不会执行里面的代码。当然你可以手动把变量值改成 20 以上的数字再试试。</p>
<h2 id="否则"><a class="header" href="#否则">否则</a></h2>
<p>现在想完善一下刚才的程序，在任务完成数量不达标时提示玩家需要完成更多任务，那么以目前学到的知识，我们可以写成这样：</p>
<pre><code class="language-gdscript">func _ready():
    var 任务完成数 = 10
    if 任务完成数 &gt;= 20:
        print(&quot;恭喜通关了&quot;)
    if 任务完成数 &lt; 20:
        print(&quot;完成的任务还不够多&quot;)
</code></pre>
<p>这样虽然可以实现效果，但是我们可以发现两个 if 的条件语句正好相反，这时可以把第二个 if 语句替换成 <code>else</code> 语句：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关了&quot;)
else:
    print(&quot;完成的任务还不够多&quot;)
</code></pre>
<p>很明显这个 <code>else</code> 就是<strong>否则</strong>的意思，当上一个 if 条件不满足时则执行。</p>
<h2 id="否则-如果"><a class="header" href="#否则-如果">否则-如果</a></h2>
<p>现在我们想让这个例子更复杂一些，具体规则如下：</p>
<ul>
<li>当完成 20 个任务时显示 <strong>恭喜通关</strong></li>
<li>完成 15-19 个任务时显示 <strong>马上就完成了</strong></li>
<li>完成 5-14 个任务时显示 <strong>加油</strong></li>
<li>完成 5 个以下时显示 <strong>这才刚刚开始</strong></li>
</ul>
<p>于是我们可以写出：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关&quot;)
else:
    if 任务完成数 &gt;= 15:
        print(&quot;马上就完成了&quot;)
    else:
        if 任务完成数 &gt;= 5:
            print(&quot;加油&quot;)
        else:
            print(&quot;这才刚刚开始&quot;)
</code></pre>
<p>这一层一层的 else 语句看起来实在是不好看，那么再认识一个新的关键字：<code>elif</code></p>
<p><code>elif</code> 就是 else 和 if 的组合形式，它会在上一个 if 的条件不满足时判断自身条件，如果自身条件满足则执行自己的代码，同时 <code>elif</code> 可以多个串联使用。</p>
<p>修改之前的代码，使用 <code>elif</code> 语句的结果如下：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关&quot;)
elif 任务完成数 &gt;= 15:
    print(&quot;马上就完成了&quot;)
elif 任务完成数 &gt;= 5:
    print(&quot;加油&quot;)
else:
    print(&quot;这才刚刚开始&quot;)
</code></pre>
<hr />
<blockquote>
<p>[!tip] 条件判断可以避免重复</p>
<p>想想我们的条件中提到的是<strong>15-19</strong>个任务显示<strong>马上就完成了</strong>，但为什么我们的 if 和 elif 后面之判断了 <code>任务完成数 &gt;= 15</code> 呢？</p>
<p>这里就要想一下 else 和 elif 的一个特点：<strong>只有在上一个 if 或 elif 的条件不满足时才判断。</strong></p>
<p>由于第一个 if 已经判断了 <code>任务完成数 &gt;= 20</code> 的情况，那么下面的所有 elif 和 else 中的<code>任务完成数</code>就不可能包含 20，所以我们就只判断 <code>&gt;= 15</code> 即可。</p>
</blockquote>
<blockquote>
<p>[!tip] bool 值变量可以直接放到表达式里</p>
<p>一个变量也可以组成表达式，假设有个变量 <code>var a = true</code>，想判断 a 是否是 true 时千万不要写 <code>if a == true</code>，直接写 <code>if a</code> 即可。（<del>虽然写成第一种也不会出错，但就是会显得自己编程水平不好......</del>）</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域"><a class="header" href="#作用域">作用域</a></h1>
<p>我们来看一段代码：</p>
<pre><code class="language-gdscript">var a = 10
if a &gt; 0:
    var b = 6
print(b)
</code></pre>
<p>看起来没有什么问题，应该会显示一个数字 6 吧？</p>
<p>运行一下试试，不出意外的话就会出现意外了，Godot 说 <code>print(b)</code> 是错误的，因为变量 b 不存在。</p>
<p>这也很好理解，比如我们把变量 a 的初始值改成 -100，那个 if 就不会执行，自然就没有执行到 <code>var b = 6</code> 这一行，此时确实没有变量 b。</p>
<p>这里介绍一下变量作用域，也就是变量的生效范围。</p>
<p>规则只有一条：<strong>内层代码块可以访问外层代码块的变量，但反之不行。</strong></p>
<p>上例中，<code>var b = 6</code> 这一句话就是在 if 的内层作用域当中的，而在 if 之外的 <code>print(b)</code> 在位外层作用域，就不能访问内层的变量。</p>
<p>现在修改代码：</p>
<pre><code class="language-gdscript">var a = 10
if a &gt; 0:
    var b = 6
    print(a)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活狐狸彩票"><a class="header" href="#整活狐狸彩票">整活：狐狸彩票</a></h1>
<p>这节整活来实现一个买彩票的小游戏，简单概括如下：</p>
<ul>
<li>刚开始你有 1000 块钱</li>
<li>彩票售价 100 块</li>
<li>彩票下注需要两个数字，这两个数字都是个位数，不能是 0</li>
<li>猜中一个数奖金 300，猜中两个奖金 3000</li>
</ul>
<p>玩起来大概这样：</p>
<p><img src="Part2/./images/huli.gif" alt="狐狸彩票" /></p>
<h2 id="场景创建-1"><a class="header" href="#场景创建-1">场景创建</a></h2>
<p>这个界面需要这么几个东西：</p>
<ul>
<li>标题</li>
<li>两个数字输入框</li>
<li>一个购买按钮</li>
<li>一个显示结果的 label</li>
<li>一个显示钱包的 label</li>
</ul>
<p>我创建的节点长这样：</p>
<p><img src="Part2/./images/huli_node.png" alt="node" /></p>
<h2 id="逻辑分析"><a class="header" href="#逻辑分析">逻辑分析</a></h2>
<p>我们现在已经知道了游戏的逻辑，但是该如何将其转换成代码呢？</p>
<p>首先我们需要一个变量来保存钱包里的钱，并在按下购买按钮时对其进行判断，如果金钱足够则扣钱并进行买彩票的逻辑，如果金钱不足则显示钱不够。</p>
<p>所以我们可以得到这样一段伪代码：</p>
<pre><code>当按下按钮时:
    if 钱包的钱足够买一张彩票:
        扣钱
        获取输入的两个数字
        随机抽取两个数
        判断随机数和输入的数字是否相等并以此产生奖金
        显示获奖结果
    else:
        显示“你的钱不够了！”
</code></pre>
<h2 id="我的脚本编写参考"><a class="header" href="#我的脚本编写参考">我的脚本编写参考</a></h2>
<p>这里是我编写的代码，可以作为参考，你也可以尝试自己翻译一下上面的伪代码。</p>
<p>脚本放置在最外层的 Panel 节点上，然后绑定按钮的 <code>pressed</code> 信号。</p>
<p>界面布局和组件设置一类的操作我就不再讲解了，大家随意点击自己琢磨即可，没有什么特别难的地方。</p>
<p>代码：</p>
<pre><code class="language-gdscript">extends Panel

var 钱包 = 1000

func _on_button_pressed():
	if 钱包 &gt;= 100: # 看看有钱吗？
        # 先交钱
		钱包 -= 100
        $Label3.text = &quot;钱包：&quot; + str(钱包)

        # 获取下注的两个数字
		var 下注数a = $SpinBox1.value
		var 下注数b = $SpinBox2.value

        # 随机产生两个数字
		var 随机数a = randi_range(1, 9)
		var 随机数b = randi_range(1, 9)

        # 在消息 label 上显示随机产生的两个数，最后的 &quot;\n&quot; 表示换行。
		$Label2.text = str(随机数a) + &quot;, &quot; + str(随机数b) + &quot;\n&quot;

        # 判断两个数字是否赌对了
		var a赌对了 = 下注数a == 随机数a
		var b赌对了 = 下注数b == 随机数b

        # 根据两个数字的猜测结果加钱
		if a赌对了 and b赌对了:
			$Label2.text += &quot;全猜对了！奖金 3000&quot;
			钱包 += 3000
			$Label3.text = &quot;钱包：&quot; + str(钱包)
		elif a赌对了 or b赌对了:
			$Label2.text += &quot;猜对一个，奖金 300&quot;
			钱包 += 300
			$Label3.text = &quot;钱包：&quot; + str(钱包)
		else:
			$Label2.text += &quot;你一分钱也没赚到&quot;
	else: # 穷了
		$Label2.text = &quot;你已经没钱下注了&quot;
</code></pre>
<p>这里唯一一个陌生的东西就是 <code>randi_range</code> 了，它会根据括号里填入的数字生成一个随机整数，包含这两个数以及两数之间的数。</p>
<blockquote>
<p>注意不要把钱包变量的定义放在方法里</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环"><a class="header" href="#循环">循环</a></h1>
<p>某些代码可能会反复执行多次，比如咱们要显示 100 个 <code>hello</code>，利用循环语句即可只写一个 print。</p>
<p>循环语句语法格式：</p>
<pre><code>while &lt;条件表达式&gt;:
    &lt;代码块&gt;
</code></pre>
<p>这和基本的 if 语句是一样的，只不过换成了 <code>while</code> 关键字，执行逻辑为：如果条件为真，则执行一次代码块，然后再判断条件，如果条件还为真，则再执行代码块，然后反复判断 + 执行，直到条件为假。</p>
<p>那么咱的 100 和 <code>hello</code> 就可以这样写：</p>
<pre><code class="language-gdscript">var 计数 = 0
while 计数 &lt; 100:
    print(&quot;hello&quot;)
    计数 += 1
</code></pre>
<blockquote>
<p>可以尝试思考一下，执行完这段代码后，<code>计数</code>变量的值是多少？</p>
</blockquote>
<h2 id="死循环"><a class="header" href="#死循环">死循环</a></h2>
<p>写循环时最容易出现的错误就是死循环，死循环并不是说循环死了，而是循环一直活着，例如：</p>
<pre><code class="language-gdscript">var 计数 = 0
while 计数 &lt; 100:
    print(&quot;hello&quot;)
</code></pre>
<p>我删掉了 <code>计数 += 1</code> 这一句代码，此时的 <code>计数</code> 变量将一直为 0，while 的条件也就永远为 <code>true</code>，所以这个循环会反复执行停不下来，这种代码会导致游戏卡死，甚至需要任务管理器才能退出，不过好在开发阶段可以点击 Godot 右上角的停止按钮来结束游戏。</p>
<blockquote>
<p>[!note]</p>
<p>游戏画面的更新和执行代码并不是同时进行的，他们的执行顺序可以简单理解为交叉进行，例如：</p>
<p>代码 -&gt; 更新画面 -&gt; 代码 -&gt; 更新画面 -&gt; 代码 -&gt; 更新画面 -&gt; ...</p>
<p>由于代码执行的很快，所以玩家眼中游戏画面是连续的，但如果现在有一个死循环或很长很长的循环，画面自然就会卡住。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>现在假设我们要给玩家设计个背包，可以装三个物品：</p>
<pre><code class="language-gdscript"># 只是举个例子，暂时就存字符串了。
var 背包格子1 = &quot;水瓶&quot;
var 背包格子2 = &quot;钥匙&quot;
var 背包格子3 = &quot;金币&quot;
print(&quot;背包中有：&quot;)
print(背包格子1)
print(背包格子2)
print(背包格子3)
</code></pre>
<p>这样我们就定义了三个变量来表示三个背包格子，但如果背包升级了呢？现在变成了 10 个格子，总不能定义 10 个变量吧。</p>
<h2 id="数组定义"><a class="header" href="#数组定义">数组定义</a></h2>
<p>于是我们来认识一个新的数据类型：<code>Array</code>，中文名<strong>数组</strong>（也有人叫集合）。</p>
<p>数组就是一堆数据构成的组，在 GDScript 中使用一对方括号表示数组，在方括号中填入要保存的数据，数据之间用逗号分隔，例如使用数组制作背包：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
</code></pre>
<h2 id="数组元素引用"><a class="header" href="#数组元素引用">数组元素引用</a></h2>
<p>这样咱就把很多物品放到了一个变量里，在想要访问背包中的物品时，使用 <code>数组变量名[下标]</code> 来访问：</p>
<pre><code class="language-gdscript">print(&quot;背包中有：&quot;)
print(背包[0]) # 显示：水瓶
print(背包[1]) # 显示：钥匙
print(背包[2]) # 显示：金币
print(背包) # 显示：[&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
</code></pre>
<p>方括号里的数字其实就是序号，这里的 <code>[0]</code> 表示背包中的第一个东西，也就是 <code>水瓶</code>。</p>
<p>这种语法也可以用来给数组中的元素赋值，例如：</p>
<pre><code class="language-gdscript">背包[0] = &quot;空&quot; # 把水喝了
</code></pre>
<blockquote>
<p>[!tip] 下标从 0 开始数</p>
<p>程序员笑话：你的右手有几根手指头？0.1.2.3.4，四根！</p>
</blockquote>
<h2 id="添加数据"><a class="header" href="#添加数据">添加数据</a></h2>
<p>使用 <code>&lt;数组变量&gt;.append(&lt;值&gt;)</code> 的形式可以向数组中添加新的值，例如：</p>
<pre><code class="language-gdscript">背包.append(&quot;苹果&quot;)
背包.append(&quot;一本书&quot;)
</code></pre>
<h2 id="获取长度"><a class="header" href="#获取长度">获取长度</a></h2>
<p>使用 <code>len(&lt;数组变量&gt;)</code> 获取一个数组的长度，例如：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(len(背包)) # 显示一个数字 3
</code></pre>
<p>注意了，长度可不要从 0 开始数。</p>
<h2 id="删除数据"><a class="header" href="#删除数据">删除数据</a></h2>
<p>使用 <code>&lt;数组变量&gt;.remove_at(&lt;下标&gt;)</code> 删除指定位置的元素，例如：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
背包.remove_at(1)
print(背包) # 显示：[&quot;水瓶&quot;, &quot;金币&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="遍历"><a class="header" href="#遍历">遍历</a></h1>
<p>我们现在有了背包，如果现在要每行显示一个背包物品，我们可以：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
print(背包[0]) # 显示：水瓶
print(背包[1]) # 显示：钥匙
print(背包[2]) # 显示：金币
</code></pre>
<p>很明显这样做只能显示背包的前三个物品，假设背包很大就不能这样写了。</p>
<p>此时结合之前的 <code>while</code> 语句和 <code>len()</code> 获取数组长度，可以改成下面这样：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
var 下标 = 0
while 下标 &lt; len(背包):
    print(背包[下标])
    下标 += 1
</code></pre>
<p>我们声明了一个变量下标，并在循环中通过这个下标从背包中取物品，同时给下标加一，这样就可以访问背包中的每个东西，直到 <code>下标 &lt; len(背包)</code> 为 <code>false</code>，也就是下标达到背包大小时停止。</p>
<blockquote>
<p>[!tip]</p>
<p>注意不要写成 <code>下标 &lt;= len(背包)</code>，这里不能等于，因为背包的长度是 3，而 <code>背包[3]</code> 是在获取第四个值，程序会出错。</p>
</blockquote>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>上面这种把数组中每个元素都访问一次的行为被称为遍历，这种操作非常常见，于是有了一种专门为遍历而生的语法：</p>
<pre><code class="language-gdscript">for &lt;元素变量名&gt; in &lt;遍历目标&gt;:
    &lt;代码块&gt;
</code></pre>
<p>这个东西本质上还是个循环，循环次数就是遍历目标的长度，每一轮循环中，都将从遍历目标里取出一个元素放到元素变量中。</p>
<p>把之前的 while 换成 <code>for</code>，运行结果不变，代码如下：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
for 物品 in 背包:
    print(物品)
</code></pre>
<h2 id="range"><a class="header" href="#range">range</a></h2>
<p>有时候我们想直接指定循环次数，例如显示 50 个 hello，这样直接用一个变量和 while 也可以搞定，但我们可以结合 <code>range</code> 方法和 <code>for</code> 来实现同样的效果：</p>
<pre><code class="language-gdscript">for 当前次数 in range(50):
    print(&quot;Hello&quot;)
</code></pre>
<p><code>range</code> 这个方法会根据括号里的数字产生一个数组，里面分别是 1、2、3、4...直到括号里的数字，但不包括那个数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h1>
<p>某些时候我们可能想要提前结束循环，比如实现功能：显示玩家背包中金币前面的内容。</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;, &quot;帽子&quot;]

var 发现金币 = false
for 物品 in 背包:
    if 物品 == &quot;金币&quot;:
        发现金币 = true
    if not 发现金币:
        print(背包)
</code></pre>
<p>这段代码可能略微复杂，大家可以先试着理解一下，就当复习一下前面章节了。</p>
<p>当然这么麻烦的代码实际开发中是不会写的，因为 GDScript 中有两个循环控制关键字。</p>
<h2 id="break"><a class="header" href="#break">break</a></h2>
<p>首先认识第一个：<code>break</code>。</p>
<p>它的功能就是当执行到的时候<strong>跳出</strong>循环，不再进行后续操作。</p>
<p>这时就可以修改上面的代码：</p>
<pre><code class="language-gdscript">for 物品 in 背包:
    if 物品 == &quot;金币&quot;:
        break
    print(背包)
</code></pre>
<p>当发现遍历到的物品是金币时，就跳出这个 <code>for</code>，也就不再显示金币和后面的内容了。</p>
<h2 id="continue"><a class="header" href="#continue">continue</a></h2>
<p>第二个：<code>continue</code>。</p>
<p>它的功能是执行到的时候提前<strong>进入下一次</strong>循环。</p>
<p>比如现在咱们想要显示所有的个位奇数：</p>
<pre><code class="language-gdscript">for i in range(10):
    if i % 2 == 0: # 是否时偶数
        continue
    print(i)
</code></pre>
<blockquote>
<p>这个逻辑其实不用 continue 就可以，大家可以自己研究。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识面向对象"><a class="header" href="#认识面向对象">认识面向对象</a></h1>
<p>面向对象（简称OOP），最流行的编程方式。</p>
<p>对于游戏开发而言，面向对象编程方式是最符合人类逻辑的，甚至给你一种编程也是玩游戏的感觉。</p>
<p>这一章内容不多，但都是理论概念上的东西，没有啥整活章节，可能略枯燥，不过下一章整活丰富，希望各位坚持看完本章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法"><a class="header" href="#方法">方法</a></h1>
<p>我们之前简单了解过方法，知道使用 <code>func</code> 关键字表示一个方法。</p>
<p>方法本质上就是一堆代码的集合，这些代码共同构成某些功能，例如 Godot 内置的 <code>print</code> 方法就是输出文字，<code>str</code> 方法就是把某些东西转换成字符串。</p>
<p>如果我们想要创造一个自己的方法，则可以使用这种语法：</p>
<pre><code>func &lt;方法名称&gt;([参数列表]):
    &lt;方法体&gt;
</code></pre>
<p>参数列表我们下节再讲，现在，如果我们想要从两个输入框里获取文字，将它们拼接起来并显示：</p>
<pre><code class="language-gdscript">func 输出拼接结果():
    var 文字1 = $LineEdit1.text
    var 文字2 = $LineEdit2.text
    print(文字1 + 文字2)
</code></pre>
<p>然后在需要使用这段代码的地方使用调用语句：</p>
<pre><code class="language-gdscript">输出拼接结果()
</code></pre>
<p>把某段常用的代码保存成方法是一个良好的习惯，这样做可以减少代码数量，提高代码复用率，这算是方法最根本的用法。</p>
<blockquote>
<p>[!tip]</p>
<p>虽然目前没在圆括号里写任何东西，但这个括号还是不能省略的。</p>
</blockquote>
<p>完整的例子如下：</p>
<pre><code class="language-gdscript">extends Node3D

func _ready():
	输出拼接结果()
	
func 输出拼接结果():
	var 文字1 = $LineEdit1.text
	var 文字2 = $LineEdit2.text
	print(文字1 + 文字2)
</code></pre>
<p>注意不要把方法写错了位置，它不应该嵌套在另一个方法中。（方法内定义方法会在以后讲解）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法-参数"><a class="header" href="#方法-参数">方法-参数</a></h1>
<p>参数可以用来控制方法，例如我们之前接触的 <code>print(&quot;Hello&quot;)</code>，这其中的 <code>&quot;Hello&quot;</code> 就是一个参数，他控制了 print 方法要显示什么内容，再例如 <code>int(n)</code> 其中的 n 就控制把谁转换成整数。</p>
<p>现在回看我们上一节写下的方法，他只能固定的显示输入框1和输入框2的内容，如果想让他显示任意两个输入框的内容，就可以加入参数。</p>
<p>参数可以写很多个，每个参数之间使用逗号分隔，修改后的方法定义如下：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    print(文字1 + 文字2)
</code></pre>
<p>参数本质上就是变量，这些参数变量会在被调用时赋值，在调用的地方这样写：</p>
<pre><code class="language-gdscript">输出拼接结果($LineEdit1, $LineEdit2)
</code></pre>
<p>就表示将 <code>$LineEdit1</code> 的值传递给了 <code>左边的输入框</code> 这个参数变量，另一个参数同理。</p>
<blockquote>
<p>[!tip]</p>
<p><code>$xxx</code> 这种语法会得到一个 Node 类型的值，表示场景中的一个节点。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法-返回值"><a class="header" href="#方法-返回值">方法-返回值</a></h1>
<p>某些方法调用语句可以作为数值使用，例如 <code>var a = int(1.2)</code>，我们知道右侧的 <code>int(1.2)</code> 会变成数字 1，那么这个 1 就被称为 <code>int(1.2)</code> 的返回值。</p>
<p>返回值其实就是一个方法的计算结果，在方法中使用 <code>return</code> 关键字表示返回值。</p>
<p>例如我们不再希望<code>输出拼接结果</code>方法直接显示输入框拼接的结果，而是将结果保存到某个变量中，则可以修改成这样：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    return 文字1 + 文字2
</code></pre>
<p>调用的地方写成：</p>
<pre><code class="language-gdscript">var 拼接结果 = 输出拼接结果($LineEdit1, $LineEdit2)
</code></pre>
<h2 id="return-结束方法的执行"><a class="header" href="#return-结束方法的执行">return 结束方法的执行</a></h2>
<p>因为 <code>return</code> 关键字表示方法的计算结果，当结果产生时方法就没必要继续执行了，所以 <code>return</code> 关键字还会停止方法的执行，就类似循环中的 break 语句：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    return 文字1 + 文字2
    print(文字1 + 文字2) # 这句 print 是永远不会执行的。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<p>对象，其实就是平时我们口中的“东西”，每一个“东西”，在程序中都可以抽象成对象，例如游戏中的一个箱子、敌人、门，甚至是 UI 上的一个按钮、一张图片都可以理解成对象。</p>
<p>对象拥有两种最基础的东西： </p>
<ol>
<li>属性</li>
<li>方法</li>
</ol>
<p>属性是用来描述对象的，例如箱子的大小、敌人的血量，说白了就是变量，只不过这个变量是属于一个对象的。</p>
<p>方法则是对象可以进行的动作，例如打开箱子、敌人受伤、开门操作，说白了就是一段代码，也就是用 <code>func</code> 定义的方法。</p>
<blockquote>
<p>Godot 中的对象还可以有信号，这个以后再讲。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类"><a class="header" href="#类">类</a></h1>
<p>面向对象中有两个词会经常提到：<code>类</code> 和 <code>实例</code>。</p>
<p>类，可以理解成对象的模板，同时也是一种 GDScript 中的语法，定义一个类就等于定义了一种对象，但注意，是定义了一<strong>种</strong>对象而不是一个对象。</p>
<p>实例，指的是根据一个类创建出来的对象，是一个切实存在的东西。</p>
<p>例如，某个游戏有一种敌人，它拥有生命值、攻击力、等级这三个属性，刚刚这段描述这个敌人的话就等于是创建了这个敌人的类。现在玩家开始了游戏，面前生成了三只这种敌人，那么这三只敌人就被称为敌人实例。</p>
<p>再例如我们三次元生活中，比如<strong>手机</strong>，我只说手机这两个字，那么这就是类，因为手机是一<strong>种</strong>东西而不是切实存在的特定物体，但如果我说<strong>你的手机</strong>，这就是一个切实存在的特定物体，那么你的手机就是一个<strong>实例</strong>，并且是手机类的实例。</p>
<p>回到 Godot，如果你理解了上面的内容，那么你就知道 <code>$LineEdit</code> 所获取的是一个输入框实例，因为所获取到的这个输入框是场景中切实存在的。</p>
<blockquote>
<p>[!tip] 不要弄混节点名和类型</p>
<p>$ 符号后面填写的是节点的名字，这个名字可以在引擎界面左上角的节点列表中修改，如果咱把节点的名字修改成了汉字： <code>一个输入框</code>，那么代码就需要改成 <code>$一个输入框</code> 才行。</p>
<p>容易弄混的是，Godot 中输入框类的名字也是 LineEdit，记住 $ 符号后面是节点名而不是类名即可。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类成员"><a class="header" href="#类成员">类成员</a></h1>
<blockquote>
<p>阅读过程中请斟酌<code>类</code>与<code>实例</code>这两个词，理解它们的区别。</p>
</blockquote>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>属性定义于类，独立存在于每个<strong>实例</strong>中，是用来描述实例的，例如 LineEdit 的 text 属性就是描述这个输入框所输入的内容的。</p>
<pre><code class="language-gdscript">$LineEdit.text
</code></pre>
<p>其中的 <code>$LineEdit</code> 就能获取到输入框<strong>实例</strong>，后面的点符号 <code>.</code> 可以理解成汉字 <code>的</code>，就是从实例中取某个成员。</p>
<p>再读一遍这句话：属性定义于类，独立存在于每个<strong>实例</strong>中。</p>
<p>属性定义于类，这是说属性是由类指定的，一个类的所有实例都有同样的属性，例如每个 LineEdit 实例都有 text 属性，而 TextureRect 类的实例则没有 text 属性。</p>
<p>属性独立存在于每个实例中，这是说每个实例的同名属性的值是不同的，比如现在有两个输入框，也就是两个 LineEdit 实例，我们可以在这两个输入框中输入不同的内容，也是说他们俩的 text 属性的值是不同的。</p>
<blockquote>
<p>[!note] 三次元例子</p>
<p>咱已经知道手机是一个类，那么手机的颜色、电量、所有者这些就是手机的属性。</p>
</blockquote>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>方法表示<strong>实例</strong>能进行的动作。例如 LineEdit 有一个没参数的 clear 方法可以清空输入框的内容：</p>
<pre><code class="language-gdscript">$LineEdit.clear()
</code></pre>
<p>或者想要删除某个节点，可以调用它的 free 方法：</p>
<pre><code class="language-gdscript">$LineEdit.free()
</code></pre>
<blockquote>
<p>[!note] 三次元例子</p>
<p>还是说手机，手机能够开机、打电话、玩游戏，这些手机能干的事情，就是手机的方法。</p>
</blockquote>
<h2 id="对象的属性还是对象"><a class="header" href="#对象的属性还是对象">对象的属性还是对象</a></h2>
<p>如果我们想让输入框的位置产生变化，那我们可以访问它的 <code>position</code> 属性，这个属性表示的是坐标，但坐标肯定不是一个数字，所以 <code>position</code> 的类型是 <code>vector2</code>，这个 <code>vector2</code> 也是一个类，而 <code>position</code> 属性存放的则是一个 vector2 <strong>实例</strong>，他有两个属性：<code>x</code> 和 <code>y</code>，如果我们想让输入框向左下方移动一点，则可以：</p>
<pre><code class="language-gdscript">$LineEdit.position.x += 100
$LineEdit.position.y += 100
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>向下移动是增加 y 值，因为 Godot 中的 2D 坐标系正方向是向下的，且原点在屏幕左上角。</p>
</blockquote>
<blockquote>
<p>[!note] 三次元例子</p>
<p>手机的所有者，这是个什么类型的数据？</p>
<p>在完整的面向对象程序中，应该还有一个人员类，那么很明显，手机所有者这个属性的类型就是人员类，而你的手机的所有者属性所存放的值，就是你这个人员类实例。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日后再深入"><a class="header" href="#日后再深入">日后再深入</a></h1>
<p>理解面向对象需要一定过程，这一章只是带领各位初步认识一下面向对象的概念，各位需要在学习下一章的过程中逐步理解本章内容。</p>
<blockquote>
<p>Godot 的很多东西如果不会面向对象还不好学，但学面向对象又需要很多编程经验，所以本书尝试将这两部分穿插来讲。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引擎交互"><a class="header" href="#引擎交互">引擎交互</a></h1>
<p>学 GDScript 的最终目的还是 Godot。</p>
<h2 id="学习建议"><a class="header" href="#学习建议">学习建议</a></h2>
<p>某些章节可能会让你感觉云里雾里，这是因为某些内容是互相关联的，可能需要结合后几节的知识才能理解。</p>
<p>所以建议不要因为一小点看不懂就放弃。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期---单次执行周期"><a class="header" href="#生命周期---单次执行周期">生命周期 - 单次执行周期</a></h1>
<p>节点的生命周期是指节点从出生（创建）到死亡（删除）的过程，这个过程中有几个关键的时间点，我们可以在这些时间点编写我们的逻辑代码，承载这些代码的方法就被称为生命周期方法。</p>
<p>我们之前见过 <code>_ready</code> 和 <code>_process</code> 方法，它俩就是两个最常见的生命周期方法。</p>
<blockquote>
<p>[!tip] </p>
<p>生命周期方法不需要我们手动调用，Godot 会在内部自动调用它们。</p>
</blockquote>
<h2 id="_enter_tree"><a class="header" href="#_enter_tree">_enter_tree</a></h2>
<p>这个生命周期方法会在节点进入到场景树时执行，也就是节点出现时执行。</p>
<p>注意不要和下面的 <code>_ready</code> 搞混，在执行 <code>_enter_tree</code> 生命周期方法时可能还没有子节点，因为子节点还没有加入到场景树中。</p>
<h2 id="_ready"><a class="header" href="#_ready">_ready</a></h2>
<p>当节点完全准备好时执行。</p>
<p>完全准备好是指子节点都执行完毕 <code>_ready</code> 和 <code>_enter_tree</code> 方法，并且当前节点执行完 <code>_enter_tree</code> 方法。</p>
<h2 id="区分-_enter_tree-和-_ready"><a class="header" href="#区分-_enter_tree-和-_ready">区分 _enter_tree 和 _ready</a></h2>
<p>假设现在有一个这样的场景：</p>
<pre><code>Control
    LineEdit
    TextureRect
</code></pre>
<p>其中 Control 节点有两个子节点，分别是 LineEdit 和 TextureRect，并给他们三个都加上相同的脚本：</p>
<pre><code class="language-gdscript">extends Node

func _enter_tree():
    # name 是指节点的名字
    print (name + &quot; enter tree&quot;)

func _ready():
    print (name + &quot; ready&quot;)
</code></pre>
<p>运行场景后，我们会看到这样的输出结果：</p>
<pre><code>Control enter tree
LineEdit enter tree
TextureRect enter tree
LineEdit ready
TextureRect ready
Control ready
</code></pre>
<p>可见 <code>_enter_tree</code> 会最先执行，且父节点优先执行，而 <code>_ready</code> 最后执行，且父节点排在最后。</p>
<h2 id="_exit_tree-节点离开场景树"><a class="header" href="#_exit_tree-节点离开场景树">_exit_tree 节点离开场景树</a></h2>
<p>顾名思义，当节点离开场景树时执行，且子节点优先执行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期---循环执行周期"><a class="header" href="#生命周期---循环执行周期">生命周期 - 循环执行周期</a></h1>
<p>上一节认识的生命周期每个节点只会触发一次，下面这两个周期方法会在节点存在时反复执行。</p>
<h2 id="_process"><a class="header" href="#_process">_process</a></h2>
<p>我们都知道游戏画面是一帧一帧显示的，那这个 <code>_process</code> 就是每个画面帧时执行了。</p>
<p>这个方法还需要有个参数，Godot 给的默认参数名是 <code>delta</code>，它表示当前帧和上一帧之间间隔的时长，单位是秒。</p>
<h2 id="_physics_process"><a class="header" href="#_physics_process">_physics_process</a></h2>
<p>类似画面帧，游戏中进行物理效果模拟时也是一帧一帧进行的，不过这个帧不等于画面帧，Godot 默认是每秒 60 物理帧，同样他也有个 <code>delta</code> 参数，表示上一个物理帧与当前物理帧之间的间隔时长。</p>
<h2 id="画面帧和物理帧"><a class="header" href="#画面帧和物理帧">画面帧和物理帧</a></h2>
<p>画面帧和物理帧就是指 <code>_process</code> 和 <code>_physics_process</code>。</p>
<p>当我们处理一些画面显示相关的逻辑，例如按钮动画、视角移动等，建议使用 <code>_process</code>，这能保证每次画面刷新时都能看到流畅的画面变化。</p>
<p>如果要处理一些物理相关的逻辑，例如玩家移动、开门关门等，一定要使用 <code>_physics_process</code>，因为物理碰撞、摩擦等运算都是在物理帧进行的，如果某个物体在画面帧中移动，可能会导致物理帧中处理不到这次移动信息，从而影响物理模拟的真实性。</p>
<h2 id="delta"><a class="header" href="#delta">delta</a></h2>
<p>两个 process 生命周期都有个 <code>delta</code> 参数，使用这个方法可以平衡不同帧率对游戏的影响。</p>
<p>例如现在我有一个配置极高的电脑，可以保证 <code>_physics_process</code> 方法每秒执行 60 次，而你的电脑比较垃圾，只能保证 <code>_physics_process</code> 方法每秒执行 30 次。</p>
<p>然后这个游戏里有一段这样的代码：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
    position.x += 1
</code></pre>
<p>很明显，我会每秒移动 60 单位，因为我的电脑在一秒钟内执行了 60 次 <code>_physics_process</code>，而你一秒钟只能移动 30 次。</p>
<p>这时结合 delta 参数，让上面的代码变成：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
    position.x += 60 * delta
</code></pre>
<p>这时，由于 delta 有“电脑越差数值越高”的特点，修改后的代码可以保证咱俩每秒都能移动 60 的单位。</p>
<blockquote>
<p>[!note] 常用生命周期</p>
<p>最常用的生命周期就这三个： <code>_ready</code> <code>_process</code> <code>_physics_process</code>。</p>
<p>熟练掌握这三个生命周期即可实现绝大多数效果。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取输入"><a class="header" href="#获取输入">获取输入</a></h1>
<p>Godot 给我们预先写好了很多类，这其中有一个 <code>Input</code> 类专门用于获取玩家的输入信息。</p>
<p>先来介绍一个最简单的方法，<code>is_key_pressed</code>，它可以判断一个按键是否被按住，例如实现一个按 w 键向上移动：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
	if Input.is_key_pressed(KEY_W):
		position.y -= 1000 * delta
</code></pre>
<p>因为涉及到移动，所以我们把这段代码放到了 <code>_physics_process</code> 生命周期方法中。</p>
<p>根据 <code>is_key_pressed</code> 这个名字可以看出来，他是判断按键是否被按下的，也就是说这个方法的返回值是布尔类型，当按键被按下时返回 true，没按下时返回 false。它的参数是一个 KeyCode 类型的枚举，什么是枚举可以先不用考虑，总之这个参数应该是你想检测的按键，而 Godot 定义了一堆 <code>KEY_???</code> 这样的变量来表示每一个按键，上面代码中使用的 <code>KEY_W</code> 就表示了键盘上的 W 键。</p>
<p><code>is_key_pressed</code> 结合 <code>if</code> 语句，就实现了<strong>当玩家按下某个键时执行一段代码</strong>这样的逻辑，这里当按下 W 时就会执行向上移动，也就是 <code>position.y -= 1000 * delta</code>。</p>
<blockquote>
<p>关于 position 和 delta 分别在 <a href="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92//Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.html#delta">生命周期2</a> 和 <a href="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92//Part-%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%B1%BB%E6%88%90%E5%91%98.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1">类成员</a> 小节讲过</p>
</blockquote>
<h2 id="输入映射"><a class="header" href="#输入映射">输入映射</a></h2>
<p>大部分游戏都支持多种输入方式，例如一般的主机游戏都支持键鼠和手柄，虽然我们可以使用 or 运算同时判断多个按键输入，但这必定会很麻烦。</p>
<p>现在的绝大多数游戏都会有一个这样的界面：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/cs_keyboard.png" alt="cs的键位设置界面" /></p>
<p>在这种地方，游戏定义了例如移动、跳跃等动作。在代码中直接判断玩家是否进行了某种动作即可，Godot 也为我们提供了一个这样的东西。</p>
<p>打开引擎主界面菜单中的<code>项目</code> -&gt; <code>项目设置</code> -&gt; <code>输入映射</code> 选项卡，即可看到类似上图的界面，我们可以在这里添加咱们的按键映射，例如：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/input.png" alt="输入映射" /></p>
<p>在代码中，我们可以使用 <code>Input.is_action_pressed(&quot;动作名称&quot;)</code> 来获取某个动作对应的按键是否被按下，例如我们要检测上图中的 Fire 动作：</p>
<pre><code class="language-gdscript">if Input.is_action_pressed(&quot;Fire&quot;):
	print(&quot;按下了 Fire 键！&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线性输入"><a class="header" href="#线性输入">线性输入</a></h1>
<p>游戏手柄上有一些可以“输入一半”的键，比如摇杆和扳机，这时候就可以使用 <code>Input.get_action_strength(&quot;动作名称&quot;)</code> 来获取一个小数数值，范围是 0 ~ 1，表示按键移动的强度。</p>
<p>例如根据玩家向左移动摇杆的幅度控制移动速度：</p>
<pre><code class="language-gdscript">var left = Input.get_action_strength(&quot;动作名称&quot;)
if left &gt; 0:
	position.x -= left * delta * 1000
</code></pre>
<h2 id="成对输入"><a class="header" href="#成对输入">成对输入</a></h2>
<p>有时候我们会需要成对的输入，例如操控船只的加速和减速，我们可以使用 <code>Input.get_axis(&quot;反方向动作&quot;,&quot;正方向动作&quot;)</code> 来获取一个 -1 ~ 1 的值。</p>
<p>或者有些两个轴的输入，例如玩家的上下左右移动，可以使用 <code>Input.get_vector(&quot;-x动作&quot;,&quot;+x动作&quot;,&quot;-y动作&quot;,&quot;+y动作&quot;)</code> 来获取到一个 Vector2 类型的值，其中的 x 和 y 的范围是 -1 ~ 1。</p>
<p>这两个方法没什么难点，这里就不放示例了，各位亲自体验尝试以下吧。</p>
<blockquote>
<p>[!tip]</p>
<p>这些返回小数的输入获取方法，对于键盘或非线性按键的操作会返回 -1、0、1 这种整数值。</p>
</blockquote>
<h2 id="鼠标输入"><a class="header" href="#鼠标输入">鼠标输入</a></h2>
<p>鼠标的按键输入可以直接使用输入映射功能。</p>
<p>如果要获取鼠标的位置，则可以使用 <code>get_global_mouse_position()</code> 获取鼠标在 2D 世界中的坐标。</p>
<p>如果要获取鼠标的移动速度，则需要使用 <code>_input</code> 生命周期方法：</p>
<pre><code class="language-gdscript">func _input(event):
	if is_instance_of(event,InputEventMouseMotion):
		print(event.velocity)
</code></pre>
<p>这样就会输出鼠标的移动速度。</p>
<blockquote>
<p>这段代码涉及到一些没学过的东西，暂时先不解释了，暂时只要知道里面的 if 中的代码会在鼠标移动时执行即可。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packedscene实例化"><a class="header" href="#packedscene实例化">PackedScene实例化</a></h1>
<p>某些物品会在游戏中反复出现，以玩家发射的炮弹举例，炮弹可以被反复创建，且每颗炮弹都几乎相同，那么我们就可以制作一个炮弹模板，在玩家开火时创建它。</p>
<p>这个 <code>PackedScene</code> 就是模板，这俩单词翻译成中文是 <code>打包的场景</code>，也就是说模板的本质就是场景，也就是任意一个节点（及其子节点）。</p>
<blockquote>
<p>如果学过 Unity，其实这个 PackedScene 就等于 Unity 的预制体。</p>
</blockquote>
<h2 id="创建-packedscene"><a class="header" href="#创建-packedscene">创建 PackedScene</a></h2>
<p>方法有三：</p>
<ol>
<li>
<p>点击菜单栏[场景] -&gt; [新建场景]后，开始制作你的模板，并保存当前场景。</p>
</li>
<li>
<p>在任意场景对着节点列表中的某个节点右键，点击 [将分支保存为场景]。</p>
</li>
<li>
<p>在节点列表中拖拽节点到下面的文件列表中。</p>
</li>
</ol>
<blockquote>
<p>Godot 中的一个场景就是个 PackedScene</p>
</blockquote>
<h2 id="生成-packedscene"><a class="header" href="#生成-packedscene">生成 PackedScene</a></h2>
<p>想要把一个 PackedScene 使用代码创建出来，就需要先在代码中获取到 PackedScene 这个文件。</p>
<p>使用 <code>load(&quot;文件路径&quot;)</code> 来读取一个 Godot 资源，这里的文件路径使用 <code>res://</code> 开头表示项目中的资源。</p>
<p>加入咱们把某个 PackedScene 保存到了项目中的 <code>物体</code> 文件夹，例如这样：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/packed_in_res.png" alt="PackedScene" /></p>
<p>在代码中我们使用 <code>load(&quot;res://物体/某个packed_scene.tscn&quot;)</code> 即可获取到这个 PackedScene。</p>
<p>当我们想要根据这个 PackedScene 创建新物体时，可以调用它的 <code>instantiate</code> 方法，这个方法会返回创建好的节点。</p>
<p>现在我们来看下完整流程：</p>
<pre><code class="language-gdscript">var 保存好的场景 = load(&quot;res://物体/某个packed_scene.tscn&quot;)
var 新物体 = 保存好的场景.instantiate()
get_parent().add_child(新物体)
</code></pre>
<p>最后一句的 <code>get_parent()</code> 会获取当前节点的父节点，然后我们又调用了父节点的 <code>add_child</code> 方法，<code>add_child</code> 方法会给节点添加新的子节点，所以最后这一整行就是把<code>新物体</code>变成了与代码所在节点自身同级的节点。</p>
<blockquote>
<p>[!tip] </p>
<p>instantiate() 只是把节点创建来出来，但还没有添加到场景中，所以是看不到的。</p>
<p>配合 add_child 才能真正创建一个新物体。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="节点操作"><a class="header" href="#节点操作">节点操作</a></h1>
<p>我们上一节见到了 <code>get_parent</code> 和 <code>add_child</code> 方法，这一节我们多认识几个操作节点的方法。</p>
<h2 id="获取节点-1"><a class="header" href="#获取节点-1">获取节点</a></h2>
<p>我们之前见到过 <code>$xxx</code> 这种写法，其实有一个和它功能相同的方法，叫做 <code>get_node</code>，不过 <code>$</code> 符号用起来更方便，所以基本上很少会用 <code>get_node</code>。</p>
<p><code>$节点名</code> 这种写法大家应该都认识，就是获取子物体中叫做 <code>节点名</code> 的那个节点。</p>
<p>节点名可能包含一些奇怪的符号，直接把名字写在 $ 后面会出现语法错误，比如有个节点叫做 <code>外.币 巴-伯</code>，这时就可以使用字符串来表示节点名，变成 <code>$&quot;外.币 巴-伯&quot;</code> 即可。</p>
<p>准确来说，$ 符号后面填写的并不是节点名，而是节点路径，例如我们可以使用两个点 <code>..</code> 表示上一级，或者使用 <code>/root/</code> 开头表示场景根节点，下面来看几个例子：</p>
<ul>
<li>
<p><code>$&quot;../ABC&quot;</code> 获取和当前脚本所在节点同级的 ABC 节点</p>
</li>
<li>
<p><code>$&quot;../../../&quot;</code> 获取自己的父节点的父节点的父节点</p>
</li>
<li>
<p><code>$&quot;/root/BFG&quot;</code> 获取场景中最外层的 BFG 节点</p>
</li>
</ul>
<h2 id="添加节点"><a class="header" href="#添加节点">添加节点</a></h2>
<p>添加节点其实就是 <code>add_child</code> 方法，调用谁的 <code>add_child</code> 就是给谁添加子节点。</p>
<h2 id="删除节点"><a class="header" href="#删除节点">删除节点</a></h2>
<p>删除节点有两个方法：<code>free</code> 和 <code>queue_free</code>。</p>
<p>一般情况下我更建议使用 <code>queue_free</code> 来删除节点，方法名中的 queue 是队列的意思，可以理解成排队，也就是说这是让节点排队删除，而不是立刻删除。</p>
<p>而 <code>free</code> 则是立刻删除节点，在调用 <code>free</code> 时，Godot 就会立刻删除这个节点。</p>
<p>我们来看个例子：</p>
<pre><code class="language-gdscript"># 这是举例用的错误代码
free()
print(position)
</code></pre>
<p>运行这段代码游戏会报错，因为执行 <code>free</code> 时就会立刻删除这个节点，而下面的代码要输出 position，可是节点已经被删除了，哪里还有 position 呢。</p>
<p>如果我们将 <code>free</code> 换成 <code>queue_free</code> 则可以避免这个报错，Godot 会先将调用 <code>queue_free</code> 的节点记录下来，等咱们的代码执行完毕后，在空闲时间时再将它们删除。</p>
<blockquote>
<p>某些生命周期或信号事件中使用 free 会直接报错，因为 Godot 内部有一种节点锁定机制。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="还没整理的内容"><a class="header" href="#还没整理的内容">还没整理的内容</a></h1>
<h2 id="find_child"><a class="header" href="#find_child">find_child</a></h2>
<p>find_child 方法类似 find_child，不过它的参数是节点名而不是路径。</p>
<p>从名字可以看出，find 是寻找，可以理解成搜索节点，搜索范围是全部的子节点。</p>
<p>所以我们可以用 find_child 来获取藏在子节点内部甚至子子子节点中的某个节点。</p>
<p>节点名参数还可以使用 <code>*</code> 和 <code>?</code> 这种通配符，具体使用方式可以看文档。</p>
<p>还可以了解一下 find_children 方法，可以获取多个节点。</p>
<h2 id="遍历子节点"><a class="header" href="#遍历子节点">遍历子节点</a></h2>
<p><code>get_child_count</code> 可以获取当前节点的子节点个数。</p>
<p><code>get_child</code> 可以根据下标获取一个子节点。</p>
<p>结合 for 语句可以遍历全部子节点：</p>
<pre><code class="language-gdscript">for i in range(get_child_count()):
    print(get_child(i))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/js/style.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
