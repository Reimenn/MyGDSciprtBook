# 定义类

我们已经感受到了，在 Godot 中，一个 GDScript 脚本文件就是一个类，但某些情况下，我们需要一些小巧的类，我们懒得去再创建一个新的脚本文件了，此时就可以用内部类语法：

```
class <类名>:
    <类成员（方法、属性、信号等）>
```

例如我们用这种形式定义一个 伤害来源 类：

```gdscript
class 伤害来源:
    var 攻击者 = null
    var 伤害值 = 0
    var 是魔法吗 = false
```

可见，除开第一行 class 关键字外，其他的语法都与正常的类相同。

在还没有实现命名空间这一特性之前（namespace是保留关键字），在其他类文件里使用内部类可以参考如下方法：

```gdscript
#情况一：内部类在用 class_name 声明的全局类里
var 伤害 := 伤害相关.伤害来源.new()

#情况二：内部类在非全局类中，preload支持相对路径
const 伤害相关 = preload("伤害相关.gd")
const 伤害来源 = 伤害相关.伤害来源
var 伤害 := 伤害来源.new()
```

通过常量引入的类，声明变量时，可以把类型指定为常量名代表的引入类，就像其他全局类一样。

> [!note] 内部类默认继承
> 
> 未声明继承的内部类默认继承自 **RefCounted**
> 
> 自定义继承一种写法如下，另一种是把冒号移到继承类名后面并同 class 写在一行里。
> ```
> class 伤害来源:
>     extends Resource
>     pass
> ```

> [!note] 内部类的作用和局限
> 
> 上面的 `伤害来源` 例子中，这个类就没继承自任何一个节点父类，也就是说 `伤害来源` 并不是一种节点，当实例化了这个类时，游戏中确实会多出一个 `伤害来源` 实例，但这个实例不会对游戏产生直接影响，它的属性和方法仅供我们其它代码使用。
> 
> 合理利用内部类可以使代码结构更清晰，使逻辑更易懂等。
> 
> 如果一个内部类继承自资源类，那它目前不能和 @export共用，不能作为一个资源在检查器修改它。

