<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".\.\mdbook-admonish.css">
        <link rel="stylesheet" href="src/css/style.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="GDScript.html">GDScript 零基础图文入门</a></li><li class="chapter-item expanded affix "><a href="ABOUT.html">关于本文</a></li><li class="chapter-item expanded "><a href="Part1/Start.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part1/什么是编程.html"><strong aria-hidden="true">1.1.</strong> 什么是编程</a></li><li class="chapter-item expanded "><a href="Part1/第一句代码.html"><strong aria-hidden="true">1.2.</strong> 第一句代码</a></li><li class="chapter-item expanded "><a href="Part1/脚本结构.html"><strong aria-hidden="true">1.3.</strong> 脚本结构</a></li><li class="chapter-item expanded "><a href="Part1/后续预告.html"><strong aria-hidden="true">1.4.</strong> 后续预告</a></li><li class="chapter-item expanded "><a href="Part1/资源汇总.html"><strong aria-hidden="true">1.5.</strong> 资源汇总</a></li></ol></li><li class="chapter-item expanded "><a href="Part2/Start.html"><strong aria-hidden="true">2.</strong> 基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part2/变量.html"><strong aria-hidden="true">2.1.</strong> 变量</a></li><li class="chapter-item expanded "><a href="Part2/数据类型.html"><strong aria-hidden="true">2.2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="Part2/表达式与运算符.html"><strong aria-hidden="true">2.3.</strong> 表达式与运算符</a></li><li class="chapter-item expanded "><a href="Part2/强类型变量.html"><strong aria-hidden="true">2.4.</strong> 强类型变量</a></li><li class="chapter-item expanded "><a href="Part2/整活：你好XXX.html"><strong aria-hidden="true">2.5.</strong> 整活：你好XXX</a></li><li class="chapter-item expanded "><a href="Part2/代码块.html"><strong aria-hidden="true">2.6.</strong> 代码块</a></li><li class="chapter-item expanded "><a href="Part2/分支结构.html"><strong aria-hidden="true">2.7.</strong> 分支结构</a></li><li class="chapter-item expanded "><a href="Part2/作用域.html"><strong aria-hidden="true">2.8.</strong> 作用域</a></li><li class="chapter-item expanded "><a href="Part2/整活：狐狸彩票.html"><strong aria-hidden="true">2.9.</strong> 整活：狐狸彩票</a></li><li class="chapter-item expanded "><a href="Part2/循环.html"><strong aria-hidden="true">2.10.</strong> 循环</a></li><li class="chapter-item expanded "><a href="Part2/数组.html"><strong aria-hidden="true">2.11.</strong> 数组</a></li><li class="chapter-item expanded "><a href="Part2/遍历.html"><strong aria-hidden="true">2.12.</strong> 遍历</a></li><li class="chapter-item expanded "><a href="Part2/循环控制.html"><strong aria-hidden="true">2.13.</strong> 循环控制</a></li></ol></li><li class="chapter-item expanded "><a href="Part-认识面向对象/Start.html"><strong aria-hidden="true">3.</strong> 认识面向对象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-认识面向对象/方法.html"><strong aria-hidden="true">3.1.</strong> 方法</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/方法参数.html"><strong aria-hidden="true">3.2.</strong> 方法-参数</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/方法返回值.html"><strong aria-hidden="true">3.3.</strong> 方法-返回值</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/面向对象.html"><strong aria-hidden="true">3.4.</strong> 面向对象</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/类.html"><strong aria-hidden="true">3.5.</strong> 类</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/类成员.html"><strong aria-hidden="true">3.6.</strong> 类成员</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/引用类型与null.html"><strong aria-hidden="true">3.7.</strong> 引用类型与null</a></li><li class="chapter-item expanded "><a href="Part-认识面向对象/日后再深入.html"><strong aria-hidden="true">3.8.</strong> 日后再深入</a></li></ol></li><li class="chapter-item expanded "><a href="Part-引擎交互/Start.html"><strong aria-hidden="true">4.</strong> 引擎交互</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-引擎交互/生命周期1.html"><strong aria-hidden="true">4.1.</strong> 生命周期1</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/生命周期2.html"><strong aria-hidden="true">4.2.</strong> 生命周期2</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/获取输入.html"><strong aria-hidden="true">4.3.</strong> 获取输入</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/线性输入.html"><strong aria-hidden="true">4.4.</strong> 线性输入</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/整活：玩家移动.html"><strong aria-hidden="true">4.5.</strong> 整活：玩家移动</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/PackedScene实例化.html"><strong aria-hidden="true">4.6.</strong> PackedScene实例化</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/节点操作.html"><strong aria-hidden="true">4.7.</strong> 节点操作</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/整活：Fire.html"><strong aria-hidden="true">4.8.</strong> 整活：Fire</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/信号.html"><strong aria-hidden="true">4.9.</strong> 信号</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/组.html"><strong aria-hidden="true">4.10.</strong> 组</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/整活：靶子.html"><strong aria-hidden="true">4.11.</strong> 整活：靶子</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/属性导出.html"><strong aria-hidden="true">4.12.</strong> 属性导出</a></li><li class="chapter-item expanded "><a href="Part-引擎交互/整活：分数.html"><strong aria-hidden="true">4.13.</strong> 整活：分数</a></li></ol></li><li class="chapter-item expanded "><a href="Part-深入面向对象/Start.html"><strong aria-hidden="true">5.</strong> 深入面向对象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-深入面向对象/字典.html"><strong aria-hidden="true">5.1.</strong> 字典</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/脚本与类.html"><strong aria-hidden="true">5.2.</strong> 脚本与类</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/整活：敌人.html"><strong aria-hidden="true">5.3.</strong> 整活：敌人</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/封装.html"><strong aria-hidden="true">5.4.</strong> 封装</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/整活：玩家生命值.html"><strong aria-hidden="true">5.5.</strong> 整活：玩家生命值</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/继承.html"><strong aria-hidden="true">5.6.</strong> 继承</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/节点与继承.html"><strong aria-hidden="true">5.7.</strong> 节点与继承</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/重写.html"><strong aria-hidden="true">5.8.</strong> 重写</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/多态.html"><strong aria-hidden="true">5.9.</strong> 多态</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/整活：多种武器.html"><strong aria-hidden="true">5.10.</strong> 整活：多种武器</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/信号.html"><strong aria-hidden="true">5.11.</strong> 信号</a></li><li class="chapter-item expanded "><a href="Part-深入面向对象/整活：更换武器的UI提示.html"><strong aria-hidden="true">5.12.</strong> 整活：更换武器的UI提示</a></li></ol></li><li class="chapter-item expanded "><a href="Part-进阶技巧/Start.html"><strong aria-hidden="true">6.</strong> 进阶技巧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Part-进阶技巧/枚举.html"><strong aria-hidden="true">6.1.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/单例-自动加载.html"><strong aria-hidden="true">6.2.</strong> 单例/自动加载</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/唯一名称.html"><strong aria-hidden="true">6.3.</strong> 唯一名称</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/load.html"><strong aria-hidden="true">6.4.</strong> load</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/定义类.html"><strong aria-hidden="true">6.5.</strong> 定义类</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/类型判断.html"><strong aria-hidden="true">6.6.</strong> 类型判断</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/静态.html"><strong aria-hidden="true">6.7.</strong> 静态</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/字符串格式化.html"><strong aria-hidden="true">6.8.</strong> 字符串格式化</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/存档与读档.html"><strong aria-hidden="true">6.9.</strong> 存档与读档</a></li><li class="chapter-item expanded "><a href="Part-进阶技巧/函数式编程.html"><strong aria-hidden="true">6.10.</strong> 函数式编程</a></li></ol></li><li class="chapter-item expanded "><a href="待整理的内容.html"><strong aria-hidden="true">7.</strong> 还没整理的内容</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Reimenn/MyGDSciprtBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gdscript-零基础图文入门"><a class="header" href="#gdscript-零基础图文入门">GDScript 零基础图文入门</a></h1>
<p>各位热爱游戏的小伙伴们大家好。</p>
<p>随着 Godot 的热度越来越高，有很多无程序开发基础的小伙伴认识了 Godot，个人认为 Godot 从 4.0 版本开始，已经成为了最适合游戏开发新人上手的引擎（易上手 不等于 功能简单），她相较于 Unity 更易学习，且功能足够各位开发者实现自己的梦中游戏。</p>
<p>开发游戏通常离不开编写代码，Godot 支持的编程语言中 <code>GDScript</code> 和 <code>C#</code> 是使用最广泛的：</p>
<ul>
<li>
<p><code>C#</code> 是微软公司开发的编程语言，虽然普及率不如 <code>Java</code>、<code>Python</code> 等“超一线”语言，但其功能十分强大，且拥有“宇宙第一优雅”的编程语法，但由于它真的很强大且语法实在“优雅”，学习它会花费更多的时间与精力。</p>
</li>
<li>
<p>而 <code>GDScript</code> 听名字就知道这是 Godot 自己的编程语言，因为是为游戏开发而设计，语言中的每一项功能都是为了方便我们做游戏而诞生，因此在实现同样功能的情况下，<code>GDScript</code> 会比 <code>C#</code> 少很多代码，学习起来也更加轻松。</p>
</li>
</ul>
<p>综上所述，我更推荐新人者从 <code>GDScript</code> 上手，这将是一条轻松愉悦的学习路线。</p>
<blockquote>
<p>[!tip] 新人学编程第一大门槛：选择编程语言。</p>
<p>我这里要说：随便选一个语言就行（当然现在我推荐 GDScript 了就不要乱选了233），<strong>重要的是坚持学到最后，不要中途放弃或者换语言</strong>。其实绝大多数编程语言都是共通的，就像你学会合成铁镐子后自然就会合成钻石镐一样，当你通过本文学会 <code>GDScript</code> 后，自然也会看的懂很多其它语言的代码。</p>
</blockquote>
<blockquote>
<p>[!tip] Godot 版本</p>
<p>编写本文时 Godot 刚刚推出了 4.0 rc2，所以文中按照 4.0 版本讲解。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于本文"><a class="header" href="#关于本文">关于本文</a></h1>
<p>以前我在 Gamemaker 那边搞一对一教学来着，最近喜欢上了 Godot，发现这边完善的中文资料少之又少，尤其缺乏针对零基础新人的教程，因此我计划结合之前在 gamemaker 那边的教育经验编写本文，希望可以帮助各位。</p>
<p>我不是专业写东西的，所以文中肯定会出现问题，如有错误或疑问还请及时反馈，如果真的是本文出了问题，尽早改正可以防止误导更多人。</p>
<p>如果你有不懂的地方或者文中没提到但是想学的东西也欢迎联系我，各位的反馈和建议可以让文章更加完善。</p>
<h2 id="反馈途径"><a class="header" href="#反馈途径">反馈途径</a></h2>
<p>可通过作者（Rika）QQ：2293840045 联系我，或者直接使用 git 仓库的 issue 等功能。</p>
<blockquote>
<p>[!tip] 广告时间</p>
<p>本文作者靠在线一对一教学赚零花钱，如果你想零障碍快速学习游戏开发或者其他什么编程知识，欢迎联系我。</p>
</blockquote>
<h2 id="帮助编写"><a class="header" href="#帮助编写">帮助编写</a></h2>
<p>详见 Git 仓库的 README。</p>
<hr />
<blockquote>
<p>[!tip] 想要下载本文？</p>
<p>在这个页面的右上角有一个打印按钮，点击即可保存 PDF 版本。</p>
<p>或者，直接点击这里：<a href="print.html">下载 PDF</a>。</p>
<p>不过，由于本文一直在持续更新，还是建议在线阅读以保证能看到新内容。</p>
</blockquote>
<blockquote>
<p>Q: 为什么不录视频教程？</p>
<p>A: 首先视频教程制作太麻烦，其次，我认为通过视频学习东西其实更加费时费力，文档可以随时回头看，视频容易看一遍就自我感觉都会了。</p>
</blockquote>
<hr />
<blockquote>
<p>想给这篇文章起个名字，叫做《灵动 Godot：小白的 GDScript 编程入门》怎么样？</p>
</blockquote>
<hr />
<blockquote>
<p>本文使用 <a href="https://github.com/rust-lang/mdBook">Mdbook</a> 编写。</p>
<p>感谢 <a href="https://github.com/lightyears1998">lightyears</a> 同志提供的 GDScript 语法高亮支持。</p>
<p>感谢 <a href="https://github.com/saierXP">saierXP</a> 同志指出问题并提供建议。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>Godot 官网：<a href="https://godotengine.org/">https://godotengine.org/</a></p>
<p>Godot 最新正式版下载：<a href="https://godotengine.org/download/windows/">https://godotengine.org/download/windows/</a></p>
<p>所有版本下载：<a href="https://downloads.tuxfamily.org/godotengine/">https://downloads.tuxfamily.org/godotengine/</a></p>
<p>本文讲解 GDScript，所以下载普通版，就是没有 <code>.NET</code> 或 <code>Mono</code> 字样的版本即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是编程"><a class="header" href="#什么是编程">什么是编程？</a></h1>
<p>编程说白了就是写代码，而代码是控制计算机运行的指令。</p>
<p>对于游戏来讲，游戏中的每一处逻辑都是由代码来控制，游戏的运行离不开代码。</p>
<p>假设要实现<strong>玩家点击空格开火，不点空格回血</strong>这个逻辑，那么就需要写一段这种代码：</p>
<pre><code>游戏中的每一帧都执行：
    如果玩家点了空格：
        开火
    否则（没点空格）：
        给自己加血
</code></pre>
<blockquote>
<p>[!note] 伪代码</p>
<p>上文中这段奇怪的文字被称作<strong>伪代码</strong>，也就是说这并不是真正的程序代码，但是它可以更清晰的表达真实代码的逻辑，通常在设计某些复杂代码之前写出来当草稿用。</p>
</blockquote>
<p>看起来这好像和编程没什么关系，但我没有糊弄你，真正的代码基本就是这个样子：</p>
<pre><code class="language-gdscript">func _process(delta):
    if Input.is_action_just_pressed(&quot;space&quot;):
        fire()
    else:
        hp += 1
</code></pre>
<p>我们学习编程，实际上就是把脑海中的伪代码转换成实际代码，为了完成这个转换工作，首先需要记住一些代码语法，但请注意，代码语法十分简单，这不应该是编程学习中的重点，真正需要你费头脑的是想出那些伪代码，至于语法格式，忘了就翻翻这篇教程，忘多了就会了。</p>
<blockquote>
<p>在 IT 行业工作的程序员中有一种职位专门负责提供思路，也就是“创造伪代码”，那些底层的码农们就负责把“伪代码”翻译成程序语言。（很明显创造伪代码的人工资更高）</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一句代码"><a class="header" href="#第一句代码">第一句代码</a></h1>
<p>如果你就算只碰过一点点编程，应该也会见过这么一句话：</p>
<pre><code class="language-gdscript">&quot;Hello, World!&quot;
</code></pre>
<p>这是计算机行业的元老级 meme 之一，当人们在学习一门新编程语言时，就会想办法让那个语言把上面这几个字母显示在屏幕上。</p>
<p>这时你可以打开 Godot，创建一个 Label，然后在 text 属性中写上 <code>Hello, World!</code>，运行后（或许不用运行）就会看到屏幕上出现了这几个字母，恭喜，你学会 GDScript了！</p>
<p><img src="Part1/./images/create-label-HelloWorld.png" alt="创建HelloWorld标签" /></p>
<p>等等，那说好的代码呢？</p>
<p><del>很明显上面是一些玩笑话</del>，但我建议你还是尝试一编上面的步骤，毕竟你是一位要成为<em>边城带师</em>的人，这种点点鼠标的操作还是要熟练掌握才行的
。</p>
<blockquote>
<p>本文重点在 GDScript，不会涉及太多的引擎操作知识，如果你还不会引擎的基本操作，建议打开 Godot 到处点一点，很快你就会熟悉她的界面逻辑了。</p>
</blockquote>
<blockquote>
<p>给纯新人小伙伴的一个建议：放纵自己的好奇心，对感兴趣的东西先动手尝试再寻求帮助更好。</p>
</blockquote>
<h2 id="print"><a class="header" href="#print">print</a></h2>
<p>下面我来带大家用代码的方式显示一句话。</p>
<p>首先我们要明白 Godot 中构成游戏的基本单位是<code>节点</code>，也就是默认界面左上角的那些东西。我们写的代码被称作<code>脚本</code>（不是玩游戏开挂的那个脚本哈），每个节点可以绑定一个脚本来扩展节点的功能，因此想执行咱自己的代码，第一步就是要有一个节点。</p>
<p>目前随便创建一个节点即可，然后选中节点，点击添加脚本按钮：</p>
<p><img src="Part1/./images/create-node.gif" alt="创建节点并添加脚本" /></p>
<p>在最后出现的窗口中，是对这个新脚本的设置，建议勾上<code>内置脚本</code>选项，其余目前不用改，接着点击<code>创建</code>即可。</p>
<p>接着咱就被带到了一个代码编辑器中，看起来应该是这样：</p>
<pre><code class="language-gdscript">extends Control

# Called when the node enters the scene tree for the first time.
func _ready():
    pass # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
    pass
</code></pre>
<blockquote>
<p>第一行可能不太一样，这取决于刚刚创建的节点是什么类型。</p>
</blockquote>
<p>现在目标聚焦 <code>func _ready():</code> 这一行，在这一行的最后咱们加一个回车，然后输入 <code>print(&quot;Hello, World!&quot;)</code>，完事后这一段应该是下面这个样子：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;Hello, World!&quot;)
    pass
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>注意不要改动其他地方的代码，上面我放了三行代码只是完整代码的一部分，因为每次都贴完整代码太长了，所以我就省略了其他部分，但你不要省略。</p>
</blockquote>
<p>注意 <code>print</code> 的前面应该是一个制表符，Godot 应该会自动帮你加上，如果你发现 <code>print</code> 和下面的 <code>pass</code> 没有垂直对齐，可能需要手动在前面输入一个制表符（按Tab键输入）。</p>
<p>接下来，保存场景、运行游戏，发动你的火眼金晶在屏幕上找到 <code>Hello, World!</code> 吧！</p>
<p><img src="Part1/./images/helloWorld.png" alt="helloWorld" /></p>
<p>恭喜你已经成功运行了第一句 GDScript 代码！</p>
<blockquote>
<p>[!warning] 常见问题</p>
<ol>
<li>
<p>在编程时我们要保证自己的输入法处于英文状态，一般的编程语言不认识中文符号，看看你 print 后面的括号和双引号是英文的吗？</p>
</li>
<li>
<p><code>Hello, World!</code> 两边的双引号在这里表示<strong>中间夹着一段文字</strong>，因此不要省略这俩双引号！</p>
</li>
<li>
<p>运行的场景要选择当前编写代码的场景，不要运行错了场景。（可以点击F6直接运行当前场景）</p>
</li>
</ol>
<p>... 更多问题等待你的反馈，我会在这里解答</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p>print 这句话的功能其实就是在 Godot 引擎界面中显示一些东西，虽然玩家看不到，但对于我们开发者来讲通常会利用 print 进行一些排错工作，起到类似于日志的作用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="脚本结构"><a class="header" href="#脚本结构">脚本结构</a></h1>
<p>上一节咱们运行了一句代码，但我估计你应该还是比较蒙，这节就来看一下之前那篇代码的每一句话是什么意思。</p>
<h2 id="代码语法之注释"><a class="header" href="#代码语法之注释">代码语法之：注释</a></h2>
<p>首先来认识一个最简单的语法，它叫做<code>注释</code>。</p>
<p>因为代码本质上还是给计算机看的东西，在逻辑复杂或代码太长时，人类阅读起来非常困难，人们就在代码中穿插加入一些小笔记来解释代码的逻辑和用法，这种小笔记就是注释了。</p>
<p>在 GDScript 中输入一个井号 <code>#</code> 就表示注释，从这个符号开始到这一行结束都属于注释范围，所以再来之前那篇代码，就会发现其中很多东西都是注释（方便理解，我把注释翻译成了中文）：</p>
<pre><code class="language-gdscript">extends Control

# 在节点第一次进入场景树时执行
func _ready():
    pass # 用方法体替换这里

# 每一帧执行一次，'delta' 指上一帧和这一帧的间隔时间
func _process(delta):
    pass
</code></pre>
<p>可以看到，Godot 还贴心的留给了我们三句话。。。</p>
<blockquote>
<p>[!tip]</p>
<p>注释不会被当作代码执行，如果你给刚才的 print 前面加上 # 号，那么 print 就不会执行了，所以有时遇到了某段代码不确定要不要删除，也可以先用注释的方式临时屏蔽。（虽然规范上不建议这样做，但是一个人开发的情况下老子就是规范）</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p>GDScript 本身<strong>不支持</strong>多行注释，但可以用多行字符串语法<strong>冒充</strong>多行注释，语法为三对单引号 <code>'''多行注释1'''</code> 或者三对双引号 <code>&quot;&quot;&quot;多行注释2&quot;&quot;&quot;</code>，但不推荐使用，因为这个多行字符串是实际的脚本数据，在导出项目后仍会保留。（不建议各位使用这种语法，但学习他人代码时如果遇到了，希望各位能看懂）</p>
</blockquote>
<h2 id="代码语法之方法"><a class="header" href="#代码语法之方法">代码语法之：方法</a></h2>
<p><strong>方法</strong>这个名称实在是抽象，它还有另一个名称叫做<strong>函数</strong>，行吧，也比较抽象。。。</p>
<p>你可以把方法理解成一段保存好的代码，在需要执行的时候<strong>调用</strong>一下就会执行。</p>
<p>GDScript 中使用 <code>func</code> 表示一个方法，后面紧跟一个方法的名字，所以再看上面的代码，我们会发现其中包含两个方法，分别是<code>_ready</code>和<code>_process</code>。</p>
<p>方法的最后有一个冒号，然后另起一行的内容就是<strong>方法体</strong>，也就是这个方法所包含的代码， <code>pass</code> 关键字表示这个方法没有代码，也可以把 <code>pass</code> 替换成咱自己的代码。</p>
<blockquote>
<p>之前写的 print 下面还跟着一个 pass 呢，那个 pass 其实没用，删掉也可以。</p>
</blockquote>
<blockquote>
<p>方法和函数这两个名字我也经常混着用，如果看到后面发现我提到了函数这个词，要知道指的就是方法。</p>
</blockquote>
<p>结合官方给的注释，现在我们大致明白之前的 print 代码是怎么回事了，因为咱把 print 放在了 <code>_ready</code> 方法当中，按照注释“在节点第一次进入场景树时执行”所说，咱们的 print 就跟着 <code>_ready</code> 在节点第一次出现时执行了一次。</p>
<blockquote>
<p>[!tip] 还是有点蒙吗？</p>
<p>这一节的内容留个印象即可，后面会再详细讲解，现在只需要知道两件事：</p>
<ol>
<li>
<p><code>_ready</code> 方法中的代码会游戏刚运行时执行</p>
</li>
<li>
<p><code>_process</code> 方法中的代码会在游戏运行时的每一帧执行</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>[!tip] 啥叫场景树？</p>
<p>Godot 中把一堆节点构成的东西称作<strong>树</strong>，那么场景树就是这个场景中节点所组成的树了。</p>
<p>至于<strong>进入</strong>场景树就是指<strong>加入</strong>到场景树中，也就是游戏刚开始时了。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后续预告"><a class="header" href="#后续预告">后续预告</a></h1>
<div style="width:40%;margin: 4em auto;border:0.4em dashed #ffffff55;padding:1em">
到这里，你就没有回头路了
<div style="text-align:right">-- 沃夏·硕德</div>
</div>
<hr />
<p>为了保证学习不枯燥，后续教程中会穿插一些实践内容，这些小节标题以<code>整活</code>开头，各位小伙伴也可以整自己的活，本文整活仅供参考，大家要发挥自己的想象力。</p>
<h2 id="后续的学习路线"><a class="header" href="#后续的学习路线">后续的学习路线</a></h2>
<p>对于零基础新人来讲编程往往是最大的门槛，引擎界面的操作和节点的用法这类表面事物，自己琢磨或简单看看视频就能学会。</p>
<p>从这篇文章的标题可以看出，本文重点讲解 GDScript 编程知识，单独阅读本文并不能保证你学会 Godot，但优先学习 GDScript 能使你更轻松的学习其他教程资料。</p>
<blockquote>
<p>最后，提醒各位新人，学习 Godot 要主动自学，这并不是因为 “Godot 资料少”一类原因造成的，因为每个人的心中都有属于自己的游戏，他人的教程终究不能完全覆盖你需要的知识。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源汇总"><a class="header" href="#资源汇总">资源汇总</a></h1>
<p>考虑到 godot 学习资源稀缺，所以在此汇总了一些资源，在学习完本教程后，可继续学习。</p>
<h2 id="视频教程"><a class="header" href="#视频教程">视频教程</a></h2>
<h3 id="完整教程"><a class="header" href="#完整教程">完整教程</a></h3>
<p><a href="https://www.bilibili.com/video/BV1SP411m7aj/?spm_id_from=333.999.0.0&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">勇者传说</a>  （B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV14z4y1T7jK/?spm_id_from=333.999.0.0&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">Godot 4 吸血鬼生存复刻教程</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1No4y1L7he/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">RTS即时战略游戏</a>  （B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1Kh41137bZ/?spm_id_from=333.788&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">横向卷轴像素艺术游戏</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1bo4y1g7jA/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">资源收集游戏</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1kh4y1A7aj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">从零开始制作土豆兄弟</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1hf4y1t7P4/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">Godot 俯角射击游戏教程</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1gW4y1n7nn/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">Godot4.0 2D游戏全要素全技能速成教程</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1gR4y1G7Fa/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">Roguelike 游戏系列</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1qh4y1N71j/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">经典的俄罗斯方块游戏</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV14Y411h7Po/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">godot教程100集</a>（B 站视频）</p>
<h3 id="知识点"><a class="header" href="#知识点">知识点</a></h3>
<p><a href="https://www.bilibili.com/video/BV1Ry4y1E75T/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">Control节点实例—背包系统</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1bM4y1j7MB/?spm_id_from=333.788.recommend_more_video.4&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">2D可破坏地形</a>（B 站视频）</p>
<p><a href="https://www.bilibili.com/video/BV1c841197VJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cd15ef71fe6f4187af03b74e20f12fab">将 VS Code 连接到 Godot</a>（B 站视频）</p>
<h2 id="文档资源"><a class="header" href="#文档资源">文档资源</a></h2>
<p><a href="https://docs.godotengine.org/zh_CN/4.x/index.html">godot官方简体文档</a></p>
<p><a href="https://kidscancode.org/godot_recipes/4.x/">GODOT RECIPES</a>：英文网站，本网站收集了各种解决方案和示例，可帮助您制作所需的任何游戏系统。</p>
<p><a href="http://liuqingwen.me/">Liuqingwen 的个人博客</a>：包含众多 Godot 中文资料。</p>
<h2 id="资源网站"><a class="header" href="#资源网站">资源网站</a></h2>
<p><a href="https://godotengine.cn/">开源素材的整合站</a>：国内的开源素材的整合站，制作游戏时不再因为找可商用素材花费大量时间</p>
<p><a href="https://godot.pro/#">godot工坊</a>：国内的 Godot 论坛，包含文档、教程、资源、答疑等板块。</p>
<p><a href="https://itch.io/">itch</a>：国外的独立游戏交流平台，有很多资源和工具，还能玩其他作者的游戏。</p>
<p><a href="https://www.kenney.nl/">kenney</a>：国外的资源网站，上千免费资源任你使用，大多是 low poly 或像素风。</p>
<p><a href="https://www.gameuidatabase.com/">Game UI</a>：国外的游戏 UI 网站，主要用来学习和参考。</p>
<p><a href="https://godotassetlibrary.com/">Godot.A.L</a>：一个国外的 Godot 资源网站，看起来比 Godot 自带的资源网站高级一些。</p>
<p><a href="https://godotmarketplace.com/">Godot Market Place</a>：国外的 Godot 资源市场，类似上一个，包含付费内容。</p>
<blockquote>
<p>[!tip] 英语的重要性 </p>
<p>在此尽量罗列的是中文教程、国内的网站搬运的带字幕的教程。</p>
<p>godot的教程大部分为英文编写，掌握好英文非常重要（善用翻译工具同样重要）。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<p>GDScript 是一门十分像 Python 的语言，但针对游戏进行了很多优化。</p>
<p>本章讲解基础语法，略微涉及一些实践内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>变量是代码中用来存放数据的基本单位（抛开计算机底层不谈），游戏中会变的数据都是变量。</p>
<p>玩家的生命值、游戏分数这种直观看到的数字是变量，玩家的位置、任务进度这种抽象的数据也是变量。</p>
<p>在 GDScript 中使用 <code>var</code> 关键字声明变量，它的基本语法格式如下：</p>
<pre><code class="language-gdscript">var &lt;变量名&gt; [: 类型] [= &lt;初始值&gt;]
</code></pre>
<blockquote>
<p>[!tip] 语法格式解读</p>
<p>本文中使用上面这种格式展示语法，其中<code>尖括号</code>引用的内容表示必须填写，并把尖括号内的东西换成该填入的字符，例如<code>&lt;变量名&gt;</code>就表示这里必须要写一个变量名，至于名字是什么你可以自己来定。</p>
<p>方括号表示可选填写，例如 var 语句中的<code>类型</code>和<code>初始值</code>就可以省略。</p>
</blockquote>
<p>变量声明示例</p>
<pre><code class="language-gdscript">var 玩家名称 # 单纯声明一个变量，存储值为空，后续可以存储任意类型的数据。
var 玩家生命值 = 100 # 声明变量初值为 100，后续可以存储任意数据类型的数据。

var 敌人名称: String # 声明变量初值为空，并限定类型为字符串，后续只能存储该类型的数据。
var 敌人生命值: int = 100 # 声明变量初值并同时限定类型为整数，后续只能存储改类型的数据。

# 若指定了初始值，使用 `:=` 语法可以自动推导变量类型，等价于上一种变量声明格式，后续只能存储该类型的数据。
var 战斗回合数 := 300 # 等价于 var 战斗回合数: int = 300
</code></pre>
<p>关于变量类型我们会在下一节讲解。</p>
<h2 id="变量声明的位置"><a class="header" href="#变量声明的位置">变量声明的位置</a></h2>
<p>方法体的内部和外部都可以声明变量，但实际作用不同（具体参见[作用域]章节）：</p>
<pre><code class="language-gdscript">var 生命值 = 100 # 放在了 _ready 的外面
func _ready():
    var 生命值 = 100 # 放在了 _ready 的里面
</code></pre>
<p>当放在方法外面，也就是文件最外层时，表示这个变量属于当前节点，也就是说这个节点现在拥有了<code>生命值</code>这个属性，这个变量随着节点一起出现和消失。</p>
<p>当放在方法里面时，这个变量就成了一个临时变量，当方法被执行，程序运行到 var 语句这一行时就会创建这个变量，当方法执行完毕时，这个变量就会自动消失。</p>
<p>因此可以感觉到，如果要处理一个持续的数据，应该把变量的声明放在方法的外面。</p>
<h2 id="变量赋值"><a class="header" href="#变量赋值">变量赋值</a></h2>
<p>现在假设咱们给节点声明了<code>生命值</code>这个变量，现在希望它每帧扣除一滴血，这时就可以使用变量赋值语句来修改变量的值，赋值语句格式如下：</p>
<pre><code class="language-gdscript">&lt;变量名&gt; = &lt;新的值&gt;
</code></pre>
<p>可见其实就是把 var 关键字去掉了而已，既然这样，实现扣除一滴血的代码就可以这样写：</p>
<pre><code class="language-gdscript">func _process(delta):
    生命值 = 生命值 - 1
</code></pre>
<p>由于 _process 是每帧执行一次，所以上面代码就实现了每帧扣除一点血。</p>
<blockquote>
<p>注意不要在前面加上 var，否则就成了每帧声明一个新变量。</p>
</blockquote>
<blockquote>
<p>[!tip] 什么是关键字</p>
<p>关键字就是指 GDScript 中具有特殊含义的一些单词，例如 var，他就表示创建变量。</p>
</blockquote>
<blockquote>
<p>[!tip] 中文变量名</p>
<p>Godot 从 v4.0-beta15 的开始支持 Unicode 编码（万国码标识符，包含中文编码）。但大多数人更喜欢英文变量名，本文为了阅读方便考虑（我怕我英语渣闹笑话）采用汉字变量名。</p>
</blockquote>
<blockquote>
<p>[!tip] 声明？创建？</p>
<p>在 生命值 这个例子中声明就等于创建，但不要和后面要学到的创建（实例化）对象搞混。</p>
</blockquote>
<blockquote>
<p>[!note] 变量名命名规则</p>
<p>上面提到了，变量名是自己起的，但很明显不能乱起，例如我让一个变量叫 var，这肯定很怪，所以变量名有以下规则：</p>
<ul>
<li>
<p>不能使用数字开头</p>
</li>
<li>
<p>不能包含特殊字符，例如空格、加号等（唯一支持的符号是下划线 _）</p>
</li>
<li>
<p>不能和关键字重复</p>
</li>
</ul>
<p>本文为了阅读方便，将尽量使用中文命名，这样读者可以根据变量名快速区分 Godot 内置变量和我们定义的变量，不过在一般的开发中，变量名还是以英文为主。</p>
</blockquote>
<blockquote>
<p>变量名的一个特例，match 是个关键字，但是变量名可以为 match。当然，我们都不推荐这类同名，因为容易混淆。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>对于人类来讲，看到 <code>5</code> 就知道这是数字，看到 <code>Hello</code> 就知道这是单词，那么<strong>数字</strong>和<strong>单词</strong>这种概念在计算机中就被称为数据类型。</p>
<p>GDScript 中的基本数据类型有这些：</p>
<ul>
<li><strong>整数</strong>（<code>int</code>），例如 <code>100</code>、<code>10</code>、<code>0</code> 都是整数</li>
<li><strong>小数</strong>（<code>float</code>），例如 <code>3.14</code>、<code>0.1</code>、<code>0.0</code>、<code>4.0</code> 都是小数</li>
<li><strong>字符串</strong>（<code>String</code>），用双引号或单引号包裹的内容是字符串，例如 <code>&quot;Hello, World!&quot;</code>、<code>&quot;我是字符串&quot;</code> 都是字符串</li>
<li><strong>布尔值</strong>（<code>bool</code>），这种类型表示真假或对错，只有 <code>true</code> 和 <code>false</code> 这两个值，对应 <code>真</code> 和 <code>假</code></li>
</ul>
<p>下面是使用时的例子：</p>
<pre><code class="language-gdscript">var hp      = 100
var pos     = 4.2
var name    = &quot;Rika&quot;
var walking = false
</code></pre>
<blockquote>
<p>[!tip] 代码格式</p>
<p>实际上变量名后面可以不写空格直接跟上等于号，我为了美观让这些等于号垂直对齐了，实际开发中根据自己喜好加空格即可。</p>
<p>不过，通常的编码规范都要求能加空格的地方至少加一个空格，毕竟密麻麻的字母看起来容易眼花。</p>
<p>其实大部分代码编辑器都有自动格式化代码的功能，可以一键美化代码，可惜目前的 Godot 还不支持（截止 4.0 rc2）</p>
</blockquote>
<h2 id="数据类型转换自动"><a class="header" href="#数据类型转换自动">数据类型转换（自动）</a></h2>
<p>我们看一段代码：</p>
<pre><code class="language-gdscript">var a = 10
var b = 3.14
var c = a + b
</code></pre>
<p>首先我们定义了一个变量 a，它存放整数 10，又定义变量 b，存放小数 3.14，最后定义变量 c 存放 a 与 b 的和，那么问题来了，变量 c 中存放了一个什么类型的数字呢？</p>
<p><code>a + b</code> 这个式子是 <code>整数 + 小数</code> 的形式，为了能够正确的到 13.14 这个数，他的结果显然是小数类型。</p>
<p>虽然整数参与了运算，但结果是小数，也就是说这其中自动进行了数据类型的转换，不过因为是自动进行的，所以我们通常不用在意。</p>
<blockquote>
<p>这种自动类型转换在不同语言中有不同的名字，例如有的叫 <strong>隐式类型转换</strong>，有的叫 <strong>自动类型提升</strong>，这东西和计算机存储数据的原理有关，在这里就不过多讨论了。</p>
</blockquote>
<h2 id="为什么需要数据类型转换"><a class="header" href="#为什么需要数据类型转换">为什么需要数据类型转换？</a></h2>
<p>我们再看一段代码：</p>
<pre><code class="language-gdscript">print(10 / 3)
</code></pre>
<p>思考，这会显示什么呢？</p>
<p>按道理讲这应该会显示 3.一堆3，但实际我们只能看到一个数字 3，这是因为这个 <code>10 / 3</code> 是整数运算，这种情况下得到的结果也必定是整数，因此就看不到小数点后面的内容了。</p>
<p>这时我们可以手动修改一下：</p>
<pre><code class="language-gdscript">print(10 / 3.0)
</code></pre>
<p>对于 GDScript 来说，只要数字包含小数点，即便小数位全是 0，这个数也是小数类型，所以修改后的 print 就能正常显示 3.一堆3 了。并且这其中还对整数 10 进行了自动类型转换。</p>
<blockquote>
<p>计算机存储空间有限，小数位数肯定也有限，实际显示的是 <code>3.33333333333333</code>，不会特别长。</p>
</blockquote>
<blockquote>
<p>如果想要运行看看效果，记得把这些代码都放到 <code>_ready():</code> 这个方法体中再运行游戏。</p>
</blockquote>
<h2 id="数据类型转换手动"><a class="header" href="#数据类型转换手动">数据类型转换（手动）</a></h2>
<p>有自动类型转换，肯定也就有手动类型转换了，现在把刚刚的 <code>10 / 3</code> 代码稍作修改：</p>
<pre><code class="language-gdscript">var a = 10
var b = 3
print(a / b)
</code></pre>
<p>这个的结果大家已经知道，就是 3，现在假设，变量 a 和 b 是从其他地方获取的值，这个值就是整数，不能通过添加小数点的方式让它变成小数。</p>
<p>于是需要我们手动进行类型转换了，它的语法格式如下：</p>
<pre><code>&lt;目标类型&gt;(&lt;被转换的值&gt;)
</code></pre>
<p>其中目标类型可选如下：</p>
<ul>
<li><code>int</code> - 整数</li>
<li><code>float</code> - 小数</li>
<li><code>bool</code> - 布尔值</li>
<li><code>str</code> - 字符串</li>
</ul>
<p>我们需要把整数变成小数，所以目标类型就是 <code>float</code>，接着来修改 <code>print</code> 这一行：</p>
<pre><code class="language-gdscript">print(float(a) / float(b)) # 只给一个变量加上 float 也行，另一个会自动转换类型
</code></pre>
<p>接着就能再次看到 3.一堆3 了。</p>
<blockquote>
<p>[!tip] 四舍五入</p>
<p><code>int(1.9)</code> 的结果是 1，也就是直接抛弃小数，如果想要四舍五入取整，可以改成 <code>round(1.9)</code>，这样结果就是 2 了。</p>
</blockquote>
<blockquote>
<p>[!tip] 函数调用</p>
<p>你应该已经发现，<code>float(XXX)</code> 这种东西和 <code>print(XXX)</code> 的格式一摸一样，这种格式被称为<strong>方法调用</strong>，在后面方法章节会单独讲解。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式与运算符"><a class="header" href="#表达式与运算符">表达式与运算符</a></h1>
<p>表达式是由一些值和运算符组成的式子，例如 <code>10 + 2</code> 这种。</p>
<p>GDScript 中表达式分为这么几类：</p>
<ul>
<li>算数表达式</li>
<li>关系表达式</li>
<li>逻辑表达式</li>
<li>赋值表达式</li>
</ul>
<h2 id="算术表达式"><a class="header" href="#算术表达式">算术表达式</a></h2>
<p>顾名思义，算是表达式就是指数学运算的式子，例如 <code>5 + 2</code> <code>100 * 0.5</code> 等，运算符有这些：</p>
<ul>
<li><code>+</code> 加</li>
<li><code>-</code> 减</li>
<li><code>*</code> 乘</li>
<li><code>/</code> 除</li>
<li><code>%</code> 求余（取模）</li>
</ul>
<p>最后一个取余数可能有点忘了是什么，其实就是小学二年级还没学小数的时候，“两个数除不尽”剩下的那个数，例如：</p>
<pre><code class="language-gdscript">print(10 % 3) # 显示 1，因为 10 / 3 商 3 余 1
print(15 % 5) # 显示 0，因为 15 / 5 商 3 余 0，正好除尽
</code></pre>
<p>同时不要忘记先算乘除后算加减，必要时使用括号改变运算顺序：</p>
<pre><code class="language-gdscript">((10 + 4) * 2 - 8) * 2
</code></pre>
<p>不要轻视这个小学知识点，在修改代码时可能会忘记前后的符号导致运算优先级出错，这种 bug 找起来十分麻烦。</p>
<blockquote>
<p>[!tip] % 的优先级</p>
<p>是先求余还是先加减乘除？哈哈，我不告诉你。</p>
<p>当你的式子很长时，建议用一个临时变量保存一下中间结果，保证编程思路的清晰比什么都重要。</p>
<p>如果真的要在式子里混合求余运算符呢？那就加括号呗。</p>
<p>（<del>我写了七八年代码也没记住 % 的优先级，毕竟没有必要记住</del>）</p>
</blockquote>
<blockquote>
<p>[!note] 负数</p>
<p>直接在数字或变量前加一个减号即可表示负数，例如 <code>print(-10)</code>，或是先 <code>var a = 1</code> 再 <code>print(-a)</code> 即可显示 <code>-1</code></p>
</blockquote>
<blockquote>
<p>[!note] 字符串拼接</p>
<p>加号 + 的两侧若为字符串，还表示字符串拼接，例如 <code>var a = &quot;a&quot; + &quot;b&quot;</code>，那么 a 里面就会存放 <code>ab</code> 这两个字符。</p>
</blockquote>
<h2 id="关系表达式"><a class="header" href="#关系表达式">关系表达式</a></h2>
<p>关系表达式的运算符如下：</p>
<ul>
<li><code>&gt;</code> 大于</li>
<li><code>&lt;</code> 小于</li>
<li><code>&gt;=</code> 大于等于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>==</code> 等于</li>
<li><code>!=</code> 不等于</li>
</ul>
<p>这些应该也没什么好讲的，那么看一句代码：</p>
<pre><code class="language-gdscript">print(10 &gt; 9)
</code></pre>
<p>嗯，很简单，可是......它会显示什么呢？</p>
<p>这时要了解关系表达式的一个特点：它的结果是布尔值，也就是 true 或 false。</p>
<p>因为 <code>10 &gt; 9</code> 这是个正确的不等式，所以结果是 true，假如有一句 <code>print(10 == 9)</code>，那么这就会显示 <code>false</code> 了。</p>
<h2 id="逻辑表达式"><a class="header" href="#逻辑表达式">逻辑表达式</a></h2>
<p>逻辑表达式的运算符有这些：</p>
<ul>
<li><code>not</code> 非（否）</li>
<li><code>and</code> 与（同时为 true）</li>
<li><code>or</code> 或（任意为 true）</li>
</ul>
<p>乍一看比较蒙，根据括号里的词语理解一下，这三个运算符是对布尔值进行计算的。</p>
<p>第一个 <code>not</code> 是一个一元运算符，它只对一个数据进行操作，写在被操作数的前面，例如 <code>not false</code> 就表示 <code>true</code>。</p>
<p><code>and</code> 运算符只有在两侧都为 <code>true</code> 时结果才是 <code>true</code>，否则结果一律为 <code>false</code></p>
<p><code>or</code> 与 <code>and</code> 相反，两侧都为 <code>false</code> 结果才是 <code>false</code>，否则结果为 <code>true</code>。或者理解成只要有一个 <code>true</code>，结果就是 <code>true</code>。</p>
<h2 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h2>
<p>我们一直看到的等于号 <code>=</code> 其实就是一个赋值运算符，它的作用就是把右边的值放到左边的变量中。</p>
<p>其他的常用赋值运算符还有 <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code>，他们分别表示根据变量中原有的值进行相对运算并保存到变量中，例如：</p>
<pre><code class="language-gdscript">var a = 10
a += 10  # a 在原来的基础上又加了10，变成了20
a *= 2   # 由于上一句代码，a已经是20了，再乘上2，就变成了40
a /= 10  # 40 / 10 得到 4，a变成了4
print(a) # 显示 4
</code></pre>
<h2 id="多种运算符混合计算"><a class="header" href="#多种运算符混合计算">多种运算符混合计算</a></h2>
<p>我们貌似已经发现了规律：</p>
<ul>
<li>数学运算符的参数是数字，结果是数字</li>
<li>关系运算符的参数是数字，结果是布尔值</li>
<li>逻辑运算符的参数是布尔值，结果是布尔值</li>
</ul>
<p>所以，当上述多种运算符组合在一起时，会先运算数学运算符，接着是关系运算符，然后运行逻辑运算符，当然最后是赋值运算符。</p>
<blockquote>
<p>[!tip] 等于和不等于</p>
<p><code>==</code> 和 <code>!=</code> 两侧的值不一定是数字，例如 <code>&quot;Abc&quot; == &quot;Abc&quot;</code> 的结果是 <code>true</code>，<code>&quot;123&quot; == 123</code> 的结果是 <code>false</code>。</p>
</blockquote>
<h2 id="综合例子"><a class="header" href="#综合例子">综合例子</a></h2>
<p>现在来测一测自己，下面这段代码的每个 print 会显示什么？</p>
<pre><code class="language-gdscript">print(5 - 3 &lt; 10)
var a = 100
print(a &gt;= 100 and false)
a -= 99
a *= 10
print(a + 10)
</code></pre>
<p>答案在下面</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<blockquote>
<p>true</p>
<p>false</p>
<p>20</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="强类型变量"><a class="header" href="#强类型变量">强类型变量</a></h1>
<p>我们之前定义的变量是没有限定类型的，这种变量中可以存放任意类型的值，例如下面代码：</p>
<pre><code class="language-gdscript">var a = 10
a = &quot;Hello&quot;
a = false
</code></pre>
<p>变量 a 依次存放了数字 10、字符串 Hello、布尔值 false，也就是说 a 变量是不限定类型的。</p>
<p>这样的变量简单易懂，但说实话，并不易用。</p>
<p>绝大多数变量都应该只存储一种类型的数据，例如存放玩家名称的变量，肯定永远存放字符串，玩家生命值变量，肯定永远存放数字。</p>
<p>在定义变量时，在变量名后加上冒号和类型来明确变量类型，例如：</p>
<pre><code class="language-gdscript">var 生命值: int = 100
var 玩家名: String = &quot;Rika&quot;
</code></pre>
<p>这种变量是不能存放其他类型的数据的，例如 <code>生命值 = &quot;满血&quot;</code> 这样的代码就会出错，因为 <code>生命值</code> 变量是 int 类型的，不能存放字符串。</p>
<blockquote>
<p>[!tip] 什么叫“强类型”</p>
<p>可以把强类型理解成强制类型，就是强制要求变量只能存放某种类型的值，与之对应的就是弱类型，也就说不加 <code>: 类型名</code> 这样的变量。</p>
</blockquote>
<h2 id="推导类型"><a class="header" href="#推导类型">推导类型</a></h2>
<p>每次都加上一个冒号和类型会比较麻烦，所以 GDScript 提供了一种语法：<code>:=</code>，用法如下：</p>
<pre><code class="language-gdscript">var 玩家生命值 := 100     # 等于 玩家生命值: int
var 玩家名称 := &quot;Rika&quot;    # 等于 玩家名称: String
</code></pre>
<p>使用 <code>:=</code> 符号后，GDScript 会根据右侧的变量初始值推断类型，例如例子中的 <code>玩家生命值</code> 变量，由于初始值是个 int 类型的 100，所以这个变量就是 int 类型的。</p>
<p>这个语法要求变量必须有初始值，毕竟 GDScript 需要根据初始值才能去推导变量的类型。</p>
<blockquote>
<p>[!tip] 强类型有什么用？</p>
<p>看似使用强类型会比较麻烦，但强类型能显著减少我们写代码时的犯错概率，原理就不解释了，大家继续学习就能体会到。</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p>强类型语法只在声明变量的时候才用，给变量赋值的时候不能用！</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活你好xxx"><a class="header" href="#整活你好xxx">整活：你好XXX</a></h1>
<p>经历了枯燥的变量、数据类型、运算符的学习，欢迎来到第一个整活章节。</p>
<p>哈哈，也不要以为整活章节就不用学东西了，毕竟想一想，就目前学的 GDScript 能整什么活呢？</p>
<p>所以在整活章节中，我们需要学习 GDScript 操作 Godot 游戏的方法，这一节咱们实现这样一个功能：</p>
<p><img src="Part2/./images/hello.gif" alt="Hello" /></p>
<p>这里有一个按钮和一个输入框，点击按钮后，按钮上就会显示 <code>你好：&lt;输入的内容&gt;</code> 这句问候。</p>
<h2 id="场景创建"><a class="header" href="#场景创建">场景创建</a></h2>
<p>场景很简单，共有三个节点：</p>
<p><img src="Part2/./images/hello_tree.png" alt="Tree" /></p>
<p>添加好后调整它们的位置即可，怎么摆放大家随心即可。</p>
<p>接下来给最外层的 Control 节点添加一个内置脚本，暂时不需要修改里面的内容。</p>
<p>然后关键步骤来了，选中按钮，接着点击引擎右边的 <code>节点</code> 选项卡，进入 <code>信号</code> 列表，找到其中的 <code>pressed()</code> 并双击：</p>
<p><img src="Part2/./images/connect_button_pressed_1.png" alt="双击信号" /></p>
<p>然后就会看到一个弹窗，在窗口中选中添加了脚本的 Control 节点并点击连接</p>
<p><img src="Part2/./images/connect_button_pressed_2.png" alt="连接信号" /></p>
<p>然后我们的脚本中就会多出一个 <code>_on_button_pressed</code> 方法，应该长这样：</p>
<pre><code class="language-gdscript">func _on_button_pressed():
    pass # Replace with function body.
</code></pre>
<h2 id="解读"><a class="header" href="#解读">解读</a></h2>
<p>当按钮被点击时，就会发出 <code>pressed</code> 信号，而现在按钮的 <code>pressed</code> 信号连接了脚本中的 <code>_on_button_pressed</code> 方法，就意味着点击按钮就会执行这个方法，你可以在方法中先写一句 print 试试。</p>
<h2 id="获取输入"><a class="header" href="#获取输入">获取输入</a></h2>
<p>我们接下来需要获取玩家的输入，因此就要先找到输入框节点，获取节点的语法是这样的：</p>
<pre><code>$&lt;节点路径&gt;
</code></pre>
<p>目前输入框的节点路径就是他的名字，所以咱可以在 <code>_on_button_pressed</code> 方法中写下：</p>
<pre><code class="language-gdscript">var 输入框: LineEdit = $LineEdit
var 按钮: Button = $Button # 顺手把按钮也拿到
</code></pre>
<blockquote>
<p>[!tip]</p>
<p><code>LineEdit</code> 和 <code>Button</code> 是节点的类型，这些节点类型也是一种数据类型，可以用在强类型语法中。</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p><code>$</code> 语法本质上是一种简写，它的完整写法是一个方法调用，写做 <code>get_node(&quot;节点路径&quot;)</code>，不过还是 <code>$</code> 写法更简单实用。</p>
</blockquote>
<p>输入框节点的 text 属性表示输入的值，通过一个小数点的点 <code>.</code>，可以从节点中获取属性，所以：</p>
<pre><code class="language-gdscript">var 输入值: String = 输入框.text
</code></pre>
<p>按钮的显示文字也是 text 属性控制的，所以把这个输入值加上前缀，再交给按钮的 text 就完成这节整活了。</p>
<pre><code class="language-gdscript">按钮.text = &quot;你好：&quot; + 输入值
</code></pre>
<p>最终的完整方法应该长这样：</p>
<pre><code class="language-gdscript">func _on_button_pressed():
    var 输入框: LineEdit = $LineEdit
    var 按钮: Button = $Button # 顺手把按钮也拿到
    var 输入值: String = 输入框.text
    按钮.text = &quot;你好：&quot; + 输入值
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>文中代码使用了强类型语法，也可以不使用，但推荐加上</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码块"><a class="header" href="#代码块">代码块</a></h1>
<p>之前我们简单介绍了一下代码块概念，这里再复习一下。</p>
<p>代码块就是指一片代码的集合，通常使用一个冒号 <code>:</code> 开头，然后使用相同的缩进表示，某些其他语法需要由代码块来组成。</p>
<p>例如方法：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;我是代码块里第一行代码&quot;)
    print(&quot;我是代码块里第二行代码&quot;)
</code></pre>
<p>现在假设有一个 print 向右缩进了一点：</p>
<pre><code class="language-gdscript">func _ready():
    print(&quot;我是代码块里第一行代码&quot;)
        print(&quot;这一行会出错&quot;)
</code></pre>
<p>由于第二个 print 缩进和上面不一致，那么这个 print 就不属于方法的代码块了。</p>
<p>同理，向左缩进也一样：</p>
<pre><code class="language-gdscript">func _ready():
    var a = 2
var b = 200
</code></pre>
<p>上例中的变量 b 就处于 _ready 方法的外面。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分支结构"><a class="header" href="#分支结构">分支结构</a></h1>
<p>我们之前写的代码其实并没有什么逻辑可言，它们只会按照顺序一行行执行而已。</p>
<p>在真正的游戏中有很多<strong>分支</strong>，例如玩家与 NPC 对话时，如果完成了任务，NPC 就会给玩家奖励，否则 NPC 就会告诉玩家一些任务提示。这里的<strong>任务是否完成</strong>就是一个分支条件。</p>
<h2 id="如果"><a class="header" href="#如果">如果</a></h2>
<p>在程序中使用关键字 <code>if</code> 来表示分支，它的语法格式如下：</p>
<pre><code>if &lt;逻辑表达式&gt; :
    &lt;代码块&gt;
</code></pre>
<p>if 可以直接理解成汉语中的<strong>如果</strong>，当逻辑表达式的值为 <code>true</code> 时就会执行下面的代码块，否则就不执行。</p>
<p>其中的逻辑表达式就是指一条运算结果为逻辑值的式子，现在假设咱有个变量 <code>var 任务完成数 = 10</code> 来表示当前完成了几个任务，当完成 20 个任务时显示恭喜通关：</p>
<pre><code class="language-gdscript">func _ready():
    var 任务完成数 = 10
    if 任务完成数 &gt;= 20:
        print(&quot;恭喜通关了&quot;)
</code></pre>
<p>目前运行游戏的话你会发现什么也没有显示，毕竟<code>任务完成数</code>现在是10，if 后面的条件不满足，也就不会执行里面的代码。当然你可以手动把变量值改成 20 以上的数字再试试。</p>
<h2 id="否则"><a class="header" href="#否则">否则</a></h2>
<p>现在想完善一下刚才的程序，在任务完成数量不达标时提示玩家需要完成更多任务，那么以目前学到的知识，我们可以写成这样：</p>
<pre><code class="language-gdscript">func _ready():
    var 任务完成数 = 10
    if 任务完成数 &gt;= 20:
        print(&quot;恭喜通关了&quot;)
    if 任务完成数 &lt; 20:
        print(&quot;完成的任务还不够多&quot;)
</code></pre>
<p>这样虽然可以实现效果，但是我们可以发现两个 if 的条件语句正好相反，这时可以把第二个 if 语句替换成 <code>else</code> 语句：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关了&quot;)
else:
    print(&quot;完成的任务还不够多&quot;)
</code></pre>
<p>很明显这个 <code>else</code> 就是<strong>否则</strong>的意思，当上一个 if 条件不满足时则执行。</p>
<h2 id="否则-如果"><a class="header" href="#否则-如果">否则-如果</a></h2>
<p>现在我们想让这个例子更复杂一些，具体规则如下：</p>
<ul>
<li>当完成 20 个任务时显示 <strong>恭喜通关</strong></li>
<li>完成 15-19 个任务时显示 <strong>马上就完成了</strong></li>
<li>完成 5-14 个任务时显示 <strong>加油</strong></li>
<li>完成 5 个以下时显示 <strong>这才刚刚开始</strong></li>
</ul>
<p>于是我们可以写出：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关&quot;)
else:
    if 任务完成数 &gt;= 15:
        print(&quot;马上就完成了&quot;)
    else:
        if 任务完成数 &gt;= 5:
            print(&quot;加油&quot;)
        else:
            print(&quot;这才刚刚开始&quot;)
</code></pre>
<p>这一层一层的 else 语句看起来实在是不好看，那么再认识一个新的关键字：<code>elif</code></p>
<p><code>elif</code> 就是 else 和 if 的组合形式，它会在上一个 if 的条件不满足时判断自身条件，如果自身条件满足则执行自己的代码，同时 <code>elif</code> 可以多个串联使用。</p>
<p>修改之前的代码，使用 <code>elif</code> 语句的结果如下：</p>
<pre><code class="language-gdscript">if 任务完成数 &gt;= 20:
    print(&quot;恭喜通关&quot;)
elif 任务完成数 &gt;= 15:
    print(&quot;马上就完成了&quot;)
elif 任务完成数 &gt;= 5:
    print(&quot;加油&quot;)
else:
    print(&quot;这才刚刚开始&quot;)
</code></pre>
<hr />
<blockquote>
<p>[!tip] 条件判断可以避免重复</p>
<p>想想我们的条件中提到的是<strong>15-19</strong>个任务显示<strong>马上就完成了</strong>，但为什么我们的 if 和 elif 后面之判断了 <code>任务完成数 &gt;= 15</code> 呢？</p>
<p>这里就要想一下 else 和 elif 的一个特点：<strong>只有在上一个 if 或 elif 的条件不满足时才判断。</strong></p>
<p>由于第一个 if 已经判断了 <code>任务完成数 &gt;= 20</code> 的情况，那么下面的所有 elif 和 else 中的<code>任务完成数</code>就不可能包含 20，所以我们就只判断 <code>&gt;= 15</code> 即可。</p>
</blockquote>
<blockquote>
<p>[!tip] bool 值变量可以直接放到表达式里</p>
<p>一个变量也可以组成表达式，假设有个变量 <code>var a = true</code>，想判断 a 是否是 true 时千万不要写 <code>if a == true</code>，直接写 <code>if a</code> 即可。（<del>虽然写成第一种也不会出错，但就是会显得自己编程水平不好......</del>）</p>
</blockquote>
<blockquote>
<p>[!tip] match 条件分支语句</p>
<p>match 语句在判断变量与大量固定值是否相等时，比 if 分支更简洁，不过由于 if 可以实现同样的功能，所以用的较少。</p>
<p>比如下面的示例判断三月份有几天。</p>
<pre><code class="language-gdscript">var 月份 = 3
match 月份:
    2:
        print(&quot;非闰年该月份有28天&quot;)
    4,6,9,11:
        print(&quot;该月份有30天&quot;)
    _:
        print(&quot;该月份有31天&quot;)
</code></pre>
<p>更多用法可以参阅<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#match">官方文档相应介绍</a>，大家可以先认识一下这个语句，但不一定能用到。</p>
</blockquote>
<blockquote>
<p>[!tip] 三元运算符（又称三目运算符）</p>
<p>比如下面的例子，判断玩家在 x 轴的正半轴还是负半轴。</p>
<pre><code class="language-gdscript">var 玩家的x轴位置 = 100
var 玩家方向 = 1 if 生命值 &gt;=0 else -1
</code></pre>
<p>夹在 <code>if</code> 和 <code>else</code> 中间的为条件语句 <code>生命值 &gt;= 0</code>，如果条件语句为真，返回 if 前的值，否则返回 else 后的值。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域"><a class="header" href="#作用域">作用域</a></h1>
<p>我们来看一段代码：</p>
<pre><code class="language-gdscript">var a = 10
if a &gt; 0:
    var b = 6
print(b)
</code></pre>
<p>看起来没有什么问题，应该会显示一个数字 6 吧？</p>
<p>运行一下试试，不出意外的话就出现意外了，Godot 说 <code>print(b)</code> 是错误的，因为变量 b 不存在。</p>
<p>这也很好理解，比如我们把变量 a 的初始值改成 -100，那个 if 就不会执行，自然就没有执行到 <code>var b = 6</code> 这一行，此时确实没有变量 b。</p>
<p>现在来了解下变量作用域，也就是变量的生效范围。</p>
<p>规则只有一条：<strong>内层代码块可以访问外层代码块的变量，但反之不行</strong>。实际上，当内层代码执行完毕后，内层的变量会被删除。</p>
<p>上例中，<code>var b = 6</code> 这一句话就是在 if 的内层作用域当中的，而在 if 之外的 <code>print(b)</code> 在位外层作用域，就不能访问内层的变量。</p>
<p>现在修改代码：</p>
<pre><code class="language-gdscript">var a = 10
if a &gt; 0:
    var b = 6
    print(b)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活狐狸彩票"><a class="header" href="#整活狐狸彩票">整活：狐狸彩票</a></h1>
<p>这节整活来实现一个买彩票的小游戏，简单概括如下：</p>
<ul>
<li>刚开始你有 1000 块钱</li>
<li>彩票售价 100 块</li>
<li>彩票下注需要两个数字，这两个数字都是个位数，不能是 0</li>
<li>猜中一个数奖金 300，猜中两个奖金 3000</li>
</ul>
<p>玩起来大概这样：</p>
<p><img src="Part2/./images/huli.gif" alt="狐狸彩票" /></p>
<h2 id="场景创建-1"><a class="header" href="#场景创建-1">场景创建</a></h2>
<p>这个界面需要这么几个东西：</p>
<ul>
<li>标题</li>
<li>两个数字输入框</li>
<li>一个购买按钮</li>
<li>一个显示结果的 label</li>
<li>一个显示钱包的 label</li>
</ul>
<p>我创建的节点长这样：</p>
<p><img src="Part2/./images/huli_node.png" alt="node" /></p>
<h2 id="逻辑分析"><a class="header" href="#逻辑分析">逻辑分析</a></h2>
<p>我们现在已经知道了游戏的逻辑，但是该如何将其转换成代码呢？</p>
<p>首先我们需要一个变量来保存钱包里的钱，并在按下购买按钮时对其进行判断，如果金钱足够则扣钱并进行买彩票的逻辑，如果金钱不足则显示钱不够。</p>
<p>所以我们可以得到这样一段伪代码：</p>
<pre><code>当按下按钮时:
    if 钱包的钱足够买一张彩票:
        扣钱
        获取输入的两个数字
        随机抽取两个数
        判断随机数和输入的数字是否相等并以此产生奖金
        显示获奖结果
    else:
        显示“你的钱不够了！”
</code></pre>
<h2 id="我的脚本编写参考"><a class="header" href="#我的脚本编写参考">我的脚本编写参考</a></h2>
<p>这里是我编写的代码，可以作为参考，你也可以尝试自己翻译一下上面的伪代码。</p>
<p>脚本放置在最外层的 Panel 节点上，然后绑定按钮的 <code>pressed</code> 信号。</p>
<p>界面布局和组件设置一类的操作我就不再讲解了，大家随意点击自己琢磨即可，没有什么特别难的地方。</p>
<p>代码：</p>
<pre><code class="language-gdscript">extends Panel

var 钱包 := 1000

func _on_button_pressed():
    if 钱包 &gt;= 100: # 看看有钱吗？
        # 先交钱
        钱包 -= 100
        $Label3.text = &quot;钱包：&quot; + str(钱包)

        # 获取下注的两个数字
        var 下注数a: int = $SpinBox1.value
        var 下注数b: int = $SpinBox2.value

        # 随机产生两个数字
        var 随机数a: int = randi_range(1, 9)
        var 随机数b: int = randi_range(1, 9)

        # 在消息 label 上显示随机产生的两个数，最后的 &quot;\n&quot; 表示换行。
        $Label2.text = str(随机数a) + &quot;, &quot; + str(随机数b) + &quot;\n&quot;

        # 判断两个数字是否赌对了
        var a赌对了: bool = 下注数a == 随机数a
        var b赌对了: bool = 下注数b == 随机数b

        # 根据两个数字的猜测结果加钱
        if a赌对了 and b赌对了:
            $Label2.text += &quot;全猜对了！奖金 3000&quot;
            钱包 += 3000
            $Label3.text = &quot;钱包：&quot; + str(钱包)
        elif a赌对了 or b赌对了:
            $Label2.text += &quot;猜对一个，奖金 300&quot;
            钱包 += 300
            $Label3.text = &quot;钱包：&quot; + str(钱包)
        else:
            $Label2.text += &quot;你一分钱也没赚到&quot;
    else: # 穷了
        $Label2.text = &quot;你已经没钱下注了&quot;
</code></pre>
<p>这里唯一一个陌生的东西就是 <code>randi_range</code> 了，它会根据括号里填入的数字生成一个随机整数，包含这两个数以及两数之间的数。</p>
<blockquote>
<p>注意不要把钱包变量的定义放在方法里，否则每次点按钮都会创建一个新的钱包变量，逻辑就错了。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环"><a class="header" href="#循环">循环</a></h1>
<p>某些代码可能会反复执行多次，比如咱们要显示 100 个 <code>hello</code>，利用循环语句即可只写一个 print。</p>
<p>循环语句语法格式：</p>
<pre><code>while &lt;条件表达式&gt;:
    &lt;代码块&gt;
</code></pre>
<p>这和基本的 if 语句是一样的，只不过换成了 <code>while</code> 关键字，执行逻辑为：如果条件为真，则执行一次代码块，然后再判断条件，如果条件还为真，则再执行代码块，然后反复判断 + 执行，直到条件为假。</p>
<p>那么咱的 100 和 <code>hello</code> 就可以这样写：</p>
<pre><code class="language-gdscript">var 计数 = 0
while 计数 &lt; 100:
    print(&quot;hello&quot;)
    计数 += 1
</code></pre>
<blockquote>
<p>可以尝试思考一下，执行完这段代码后，<code>计数</code>变量的值是多少？</p>
</blockquote>
<h2 id="死循环"><a class="header" href="#死循环">死循环</a></h2>
<p>写循环时最容易出现的错误就是死循环，死循环并不是说循环死了，而是循环一直活着，例如：</p>
<pre><code class="language-gdscript">var 计数 = 0
while 计数 &lt; 100:
    print(&quot;hello&quot;)
</code></pre>
<p>我删掉了 <code>计数 += 1</code> 这一句代码，此时的 <code>计数</code> 变量将一直为 0，while 的条件也就永远为 <code>true</code>，所以这个循环会反复执行停不下来，这种代码会导致游戏卡死，甚至需要任务管理器才能退出，不过好在开发阶段可以点击 Godot 右上角的停止按钮来结束游戏。</p>
<blockquote>
<p>[!note]</p>
<p>游戏画面的更新和执行代码并不是同时进行的，他们的执行顺序可以简单理解为交叉进行，例如：</p>
<p>代码 -&gt; 更新画面 -&gt; 代码 -&gt; 更新画面 -&gt; 代码 -&gt; 更新画面 -&gt; ...</p>
<p>由于代码执行的很快，所以玩家眼中游戏画面是连续的，但如果现在有一个死循环或很长很长的循环，画面自然就会卡住。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>现在假设我们要给玩家设计个背包，可以装三个物品：</p>
<pre><code class="language-gdscript"># 只是举个例子，暂时就存字符串了。
var 背包格子1 := &quot;水瓶&quot;
var 背包格子2 := &quot;钥匙&quot;
var 背包格子3 := &quot;金币&quot;
print(&quot;背包中有：&quot;)
print(背包格子1)
print(背包格子2)
print(背包格子3)
</code></pre>
<p>这样我们就定义了三个变量来表示三个背包格子，但如果背包升级了呢？现在变成了 10 个格子，总不能定义 10 个变量吧。</p>
<h2 id="数组定义"><a class="header" href="#数组定义">数组定义</a></h2>
<p>于是我们来认识一个新的数据类型：<code>Array</code>，中文名<strong>数组</strong>（也有人叫集合）。</p>
<p>数组就是一堆数据构成的组，在 GDScript 中使用一对方括号表示数组，在方括号中填入要保存的数据，数据之间用逗号分隔，例如使用数组制作背包：</p>
<pre><code class="language-gdscript">var 背包: Array = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
</code></pre>
<h2 id="数组元素引用"><a class="header" href="#数组元素引用">数组元素引用</a></h2>
<p>这样咱就把很多物品放到了一个变量里，在想要访问背包中的物品时，使用 <code>数组变量名[下标]</code> 来访问：</p>
<pre><code class="language-gdscript">print(&quot;背包中有：&quot;)
print(背包[0]) # 显示：水瓶
print(背包[1]) # 显示：钥匙
print(背包[2]) # 显示：金币
print(背包) # 显示：[&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
</code></pre>
<p>方括号里的数字其实就是序号，这里的 <code>[0]</code> 表示背包中的第一个东西，也就是 <code>水瓶</code>。</p>
<p>这种语法也可以用来给数组中的元素赋值，例如：</p>
<pre><code class="language-gdscript">背包[0] = &quot;空&quot; # 把水喝了
</code></pre>
<blockquote>
<p>[!tip] 下标从 0 开始数</p>
<p>程序员笑话：你的右手有几根手指头？0.1.2.3.4，四根！</p>
</blockquote>
<h2 id="添加数据"><a class="header" href="#添加数据">添加数据</a></h2>
<p>使用 <code>&lt;数组变量&gt;.append(&lt;值&gt;)</code> 的形式可以向数组中添加新的值，例如：</p>
<pre><code class="language-gdscript">背包.append(&quot;苹果&quot;)
背包.append(&quot;一本书&quot;)
</code></pre>
<h2 id="获取长度"><a class="header" href="#获取长度">获取长度</a></h2>
<p>使用 <code>len(&lt;数组变量&gt;)</code> 获取一个数组的长度，例如：</p>
<pre><code class="language-gdscript">var 背包 := [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(len(背包)) # 显示一个数字 3
</code></pre>
<p>注意了，长度可不要从 0 开始数。</p>
<h2 id="删除数据"><a class="header" href="#删除数据">删除数据</a></h2>
<p>使用 <code>&lt;数组变量&gt;.remove_at(&lt;下标&gt;)</code> 删除指定位置的元素，例如：</p>
<pre><code class="language-gdscript">var 背包 := [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
背包.remove_at(1)
print(背包) # 显示：[&quot;水瓶&quot;, &quot;金币&quot;]
</code></pre>
<h2 id="元素的类型"><a class="header" href="#元素的类型">元素的类型</a></h2>
<p>一个数组中可以存在不同类型的数据，例如：</p>
<pre><code class="language-gdscript">var 一个数组 := [1, &quot;你好&quot;, false]
</code></pre>
<p>甚至数组内在再含一个数组：</p>
<pre><code class="language-gdscript">var 又数组 := [[1, 2, 3], [1, 2, 3]]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="遍历"><a class="header" href="#遍历">遍历</a></h1>
<p>我们现在有了背包，如果要每行显示一个背包物品，我们可以：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
print(背包[0]) # 显示：水瓶
print(背包[1]) # 显示：钥匙
print(背包[2]) # 显示：金币
</code></pre>
<p>很明显这样做只能显示背包的前三个物品，假设背包很大就不能这样写了。</p>
<p>此时结合之前的 <code>while</code> 语句和 <code>len()</code> 获取数组长度，可以改成下面这样：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
var 下标 = 0
while 下标 &lt; len(背包):
    print(背包[下标])
    下标 += 1
</code></pre>
<p>我们声明了一个变量下标，并在循环中通过这个下标从背包中取物品，同时给下标加一，这样就可以访问背包中的每个东西，直到 <code>下标 &lt; len(背包)</code> 为 <code>false</code>，也就是下标达到背包大小时停止。</p>
<blockquote>
<p>[!tip]</p>
<p>注意不要写成 <code>下标 &lt;= len(背包)</code>，这里不能等于，因为背包的长度是 3，而 <code>背包[3]</code> 是在获取第四个值，程序会出错。</p>
</blockquote>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>上面这种把数组中每个元素都访问一次的行为被称为遍历，这种操作非常常见，于是有了一种专门为遍历而生的语法：</p>
<pre><code class="language-gdscript">for &lt;元素变量名&gt; in &lt;遍历目标&gt;:
    &lt;代码块&gt;
</code></pre>
<p>这个东西本质上还是个循环，循环次数就是遍历目标的长度，每一轮循环中，都将从遍历目标里取出一个元素放到元素变量中。</p>
<p>把之前的 while 换成 <code>for</code>，运行结果不变，代码如下：</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;]
print(&quot;背包中有：&quot;)
for 物品 in 背包:
    print(物品)
</code></pre>
<h2 id="range"><a class="header" href="#range">range</a></h2>
<p>有时候我们想直接指定循环次数，例如显示 50 个 hello，这样直接用一个变量和 while 也可以搞定，但我们可以结合 <code>range</code> 方法和 <code>for</code> 来实现同样的效果：</p>
<pre><code class="language-gdscript">for 当前次数 in range(50):
    print(&quot;Hello&quot;)
</code></pre>
<p><code>range</code> 这个方法会根据括号里的数字产生一个数组，里面分别是 0、1、2、3、4...直到括号里的数字，但不包括那个数，也就是最后一个数字是 49。</p>
<p>不过 GDScript 还给咱们提供了一种简写方式，直接把 <code>range(123)</code> 写成 <code>123</code> 即可，例如和上面的 <code>range(50)</code> 效果相同的 for 可以写成 <code>for 当前次数 in 50:</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h1>
<p>某些时候我们可能想要提前结束循环，比如实现功能：显示玩家背包中金币前面的内容。</p>
<pre><code class="language-gdscript">var 背包 = [&quot;水瓶&quot;, &quot;钥匙&quot;, &quot;金币&quot;, &quot;帽子&quot;]

var 发现金币 = false
for 物品 in 背包:
    if 物品 == &quot;金币&quot;:
        发现金币 = true
    if not 发现金币:
        print(物品)
</code></pre>
<p>这段代码可能略微复杂，大家可以先试着理解一下，就当复习一下前面章节了。</p>
<p>当然这么麻烦的代码实际开发中是不会写的，因为 GDScript 中有两个循环控制关键字。</p>
<h2 id="break"><a class="header" href="#break">break</a></h2>
<p>首先认识第一个：<code>break</code>。</p>
<p>它的功能就是当执行到的时候<strong>跳出</strong>循环，不再进行后续操作。</p>
<p>这时就可以修改上面的代码：</p>
<pre><code class="language-gdscript">for 物品 in 背包:
    if 物品 == &quot;金币&quot;:
        break
    print(物品)
</code></pre>
<p>当发现遍历到的物品是金币时，就跳出这个 <code>for</code>，也就不再显示金币和后面的内容了。</p>
<h2 id="continue"><a class="header" href="#continue">continue</a></h2>
<p>第二个：<code>continue</code>。</p>
<p>它的功能是执行到的时候提前<strong>进入下一次</strong>循环。</p>
<p>比如现在咱们想要显示所有的个位奇数：</p>
<pre><code class="language-gdscript">for i in range(10):
    if i % 2 == 0: # 是否时偶数
        continue
    print(i)
</code></pre>
<blockquote>
<p>这个逻辑其实不用 continue 就可以，大家可以自己研究。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="认识面向对象"><a class="header" href="#认识面向对象">认识面向对象</a></h1>
<p>面向对象（简称OOP），最流行的编程方式。</p>
<p>对于游戏开发而言，面向对象编程方式是最符合人类逻辑的，甚至给你一种编程也是玩游戏的感觉。</p>
<p>这一章内容不多，但都是理论概念上的东西，没有啥整活章节，可能略枯燥，不过下一章整活丰富，希望各位坚持看完本章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法"><a class="header" href="#方法">方法</a></h1>
<p>我们之前简单了解过方法，知道使用 <code>func</code> 关键字表示一个方法。</p>
<p>方法本质上就是一堆代码的集合，这些代码共同构成某些功能，例如 Godot 内置的 <code>print</code> 方法就是输出文字，<code>str</code> 方法就是把某些东西转换成字符串。</p>
<p>如果我们想要创造一个自己的方法，则可以使用这种语法：</p>
<pre><code>func &lt;方法名称&gt;([参数列表]):
    &lt;方法体&gt;
</code></pre>
<p>参数列表我们下节再讲，现在，如果我们想要从两个输入框里获取文字，将它们拼接起来并显示：</p>
<pre><code class="language-gdscript">func 输出拼接结果():
    var 文字1 = $LineEdit1.text
    var 文字2 = $LineEdit2.text
    print(文字1 + 文字2)
</code></pre>
<p>然后在需要使用这段代码的地方使用调用语句：</p>
<pre><code class="language-gdscript">输出拼接结果()
</code></pre>
<p>把某段常用的代码保存成方法是一个良好的习惯，这样做可以减少代码数量，提高代码复用率，这算是方法最根本的用法。</p>
<blockquote>
<p>[!tip]</p>
<p>虽然目前没在圆括号里写任何东西，但这个括号还是不能省略的。</p>
</blockquote>
<p>完整的例子如下：</p>
<pre><code class="language-gdscript">extends Node3D

func _ready():
    输出拼接结果()
    
func 输出拼接结果():
    var 文字1 = $LineEdit1.text
    var 文字2 = $LineEdit2.text
    print(文字1 + 文字2)
</code></pre>
<p>注意不要把方法写错了位置，它不应该嵌套在另一个方法中。（方法内定义方法会在以后讲解）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法-参数"><a class="header" href="#方法-参数">方法-参数</a></h1>
<p>参数可以用来控制方法，例如我们之前接触的 <code>print(&quot;Hello&quot;)</code>，这其中的 <code>&quot;Hello&quot;</code> 就是一个参数，他控制了 print 方法要显示什么内容，再例如 <code>int(n)</code> 其中的 n 就控制把谁转换成整数。</p>
<p>现在回看我们上一节写下的方法，他只能固定的显示输入框1和输入框2的内容，如果想让他显示任意两个输入框的内容，就可以加入参数。</p>
<p>参数可以写很多个，每个参数之间使用逗号分隔，修改后的方法定义如下：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    print(文字1 + 文字2)
</code></pre>
<p>参数本质上就是变量，这些参数变量会在被调用时赋值，在调用的地方这样写：</p>
<pre><code class="language-gdscript">输出拼接结果($LineEdit1, $LineEdit2)
</code></pre>
<p>就表示将 <code>$LineEdit1</code> 的值传递给了 <code>左边的输入框</code> 这个参数变量，另一个参数同理。</p>
<blockquote>
<p>[!tip]</p>
<p><code>$xxx</code> 这种语法会得到一个 Node 类型的值，表示场景中的一个节点。</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p>参数变量也支持强类型语法，例如：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框: LineEdit, 右边的输入框: LineEdit):
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法-返回值"><a class="header" href="#方法-返回值">方法-返回值</a></h1>
<p>某些方法调用语句可以作为数值使用，例如 <code>var a = int(1.2)</code>，我们知道右侧的 <code>int(1.2)</code> 会变成数字 1，那么这个 1 就被称为 <code>int(1.2)</code> 的返回值。</p>
<p>返回值其实就是一个方法的计算结果，在方法中使用 <code>return</code> 关键字表示返回值。</p>
<p>例如我们不再希望<code>输出拼接结果</code>方法直接显示输入框拼接的结果，而是将结果保存到某个变量中，则可以修改成这样：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    return 文字1 + 文字2
</code></pre>
<p>调用的地方写成：</p>
<pre><code class="language-gdscript">var 拼接结果 = 输出拼接结果($LineEdit1, $LineEdit2)
</code></pre>
<blockquote>
<p>[!note] </p>
<p>返回值也支持强类型语法，在参数列表的括号后面使用 <code>-&gt;</code> 来表示返回值的类型：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框) -&gt; String:
</code></pre>
</blockquote>
<h2 id="return-结束方法的执行"><a class="header" href="#return-结束方法的执行">return 结束方法的执行</a></h2>
<p>因为 <code>return</code> 关键字表示方法的计算结果，当结果产生时方法就没必要继续执行了，所以 <code>return</code> 关键字还会停止方法的执行，就类似循环中的 break 语句：</p>
<pre><code class="language-gdscript">func 输出拼接结果(左边的输入框, 右边的输入框):
    var 文字1 = 左边的输入框.text
    var 文字2 = 右边的输入框.text
    return 文字1 + 文字2
    print(文字1 + 文字2) # 这句 print 是永远不会执行的。
</code></pre>
<blockquote>
<p>其实这个方法应该改名了，叫做“获取拼接结果”更合适。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象"><a class="header" href="#面向对象">面向对象</a></h1>
<p>对象，其实就是平时我们口中的“东西”，每一个“东西”，在程序中都可以抽象成对象，例如游戏中的一个箱子、敌人、门，甚至是 UI 上的一个按钮、一张图片都可以理解成对象。</p>
<p>对象拥有两种最基础的东西： </p>
<ol>
<li>属性</li>
<li>方法</li>
</ol>
<p>属性是用来描述对象的，例如箱子的大小、敌人的血量，说白了就是变量，只不过这个变量是属于一个对象的。</p>
<p>方法则是对象可以进行的动作，例如打开箱子、敌人受伤、开门操作，说白了就是一段代码，也就是用 <code>func</code> 定义的方法。</p>
<blockquote>
<p>Godot 中的对象还可以有信号，这个以后再讲。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类"><a class="header" href="#类">类</a></h1>
<p>面向对象中有两个词会经常提到：<code>类</code> 和 <code>实例</code>。</p>
<p>类，可以理解成对象的模板，同时也是一种 GDScript 中的语法，定义一个类就等于定义了一种对象，但注意，是定义了一<strong>种</strong>对象而不是一个对象。</p>
<p>实例，指的是根据一个类创建出来的对象，是一个切实存在的东西。</p>
<p>例如，某个游戏有一种敌人，它拥有生命值、攻击力、等级这三个属性，刚刚这段描述这个敌人的话就等于是创建了这个敌人的类。现在玩家开始了游戏，面前生成了三只这种敌人，那么这三只敌人就被称为敌人实例。</p>
<p>再例如我们三次元生活中，比如<strong>手机</strong>，我只说手机这两个字，那么这就是类，因为手机是一<strong>种</strong>东西而不是切实存在的特定物体，但如果我说<strong>你的手机</strong>，这就是一个切实存在的特定物体，那么你的手机就是一个<strong>实例</strong>，并且是手机类的实例。</p>
<p>回到 Godot，如果你理解了上面的内容，那么你就知道 <code>$LineEdit</code> 所获取的是一个输入框实例，因为所获取到的这个输入框是场景中切实存在的。</p>
<blockquote>
<p>[!tip] 不要弄混节点名和类型</p>
<p>$ 符号后面填写的是节点的名字，这个名字可以在引擎界面左上角的节点列表中修改，如果咱把节点的名字修改成了汉字： <code>一个输入框</code>，那么代码就需要改成 <code>$一个输入框</code> 才行。</p>
<p>容易弄混的是，Godot 中输入框类的名字也是 LineEdit，记住 $ 符号后面是节点名而不是类名即可。</p>
</blockquote>
<blockquote>
<p>讲个笑话</p>
<p>面试官问眼前的小伙：</p>
<blockquote>
<p>你来介绍一下什么是类。</p>
</blockquote>
<p>小伙思考了一下，答道：</p>
<blockquote>
<p>本人工作吃苦耐劳，不懂什么是累。</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类成员"><a class="header" href="#类成员">类成员</a></h1>
<blockquote>
<p>阅读过程中请斟酌<code>类</code>与<code>实例</code>这两个词，理解它们的区别。</p>
</blockquote>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>属性定义于类，独立存在于每个<strong>实例</strong>中，是用来描述实例的，例如 LineEdit 的 text 属性就是描述这个输入框所输入的内容的。</p>
<pre><code class="language-gdscript">$LineEdit.text
</code></pre>
<p>其中的 <code>$LineEdit</code> 就能获取到输入框<strong>实例</strong>，后面的点符号 <code>.</code> 可以理解成汉字 <code>的</code>，就是从实例中取某个成员。</p>
<p>再读一遍这句话：属性定义于类，独立存在于每个<strong>实例</strong>中。</p>
<p>属性定义于类，这是说属性是由类指定的，一个类的所有实例都有同样的属性，例如每个 LineEdit 实例都有 text 属性，而 TextureRect 类的实例则没有 text 属性。</p>
<p>属性独立存在于每个实例中，这是说每个实例的同名属性的值是不同的，比如现在有两个输入框，也就是两个 LineEdit 实例，我们可以在这两个输入框中输入不同的内容，也是说他们俩的 text 属性的值是不同的。</p>
<blockquote>
<p>[!note] 三次元例子</p>
<p>咱已经知道手机是一个类，那么手机的颜色、电量、所有者这些就是手机的属性。</p>
</blockquote>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>方法表示<strong>实例</strong>能进行的动作。例如 LineEdit 有一个没参数的 clear 方法可以清空输入框的内容：</p>
<pre><code class="language-gdscript">$LineEdit.clear()
</code></pre>
<p>或者想要删除某个节点，可以调用它的 free 方法：</p>
<pre><code class="language-gdscript">$LineEdit.free()
</code></pre>
<blockquote>
<p>[!note] 三次元例子</p>
<p>还是说手机，手机能够开机、打电话、玩游戏，这些手机能干的事情，就是手机的方法。</p>
</blockquote>
<h2 id="对象的属性还是对象"><a class="header" href="#对象的属性还是对象">对象的属性还是对象</a></h2>
<p>如果我们想让输入框的位置产生变化，那我们可以访问它的 <code>position</code> 属性，这个属性表示的是坐标，但坐标肯定不是一个数字，所以 <code>position</code> 的类型是 <code>vector2</code>，这个 <code>vector2</code> 也是一个类，而 <code>position</code> 属性存放的则是一个 vector2 <strong>实例</strong>，他有两个属性：<code>x</code> 和 <code>y</code>，如果我们想让输入框向左下方移动一点，则可以：</p>
<pre><code class="language-gdscript">$LineEdit.position.x += 100
$LineEdit.position.y += 100
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>向下移动是增加 y 值，因为 Godot 中的 2D 坐标系正方向是向下的，且原点在屏幕左上角。</p>
</blockquote>
<blockquote>
<p>[!note] 三次元例子</p>
<p>手机的所有者，这是个什么类型的数据？</p>
<p>在完整的面向对象程序中，应该还有一个人员类，那么很明显，手机所有者这个属性的类型就是人员类，而你的手机的所有者属性所存放的值，就是你这个人员类实例。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用类型与-null"><a class="header" href="#引用类型与-null">引用类型与 null</a></h1>
<p>与<strong>引用类型</strong>对应的是<strong>值类型</strong>，这是两种数据的存储方式。</p>
<h2 id="值类型"><a class="header" href="#值类型">值类型</a></h2>
<p>我们来看这段代码：</p>
<pre><code class="language-gdscript">var a = 10
var b = a
a += 10
print(a)
print(b)
</code></pre>
<p>这段代码会输出两个数字，依次是 <code>20</code> 和 <code>10</code>，下面是解释：</p>
<ul>
<li>
<p>首先，我们声明了个变量 a，里面存放了 10，然后定义变量 b，里面存放 a 的值，所以 b 中也存放了一个 10。</p>
</li>
<li>
<p>接下来我们对 a 自增 10，使得 a 变量的值变成了 20，此时我们的游戏中就有了两个数字，分别是 20 和 10。</p>
</li>
<li>
<p>也就是说 <code>var b = a</code> 这一行代码，会将 a 的值复制一份存到变量 b 中，实际上两个变量的值互不影响。</p>
</li>
</ul>
<p>这种类型的数据，就被称为<strong>值类型</strong>数据。</p>
<p>我们学过的<strong>数字</strong>、<strong>字符串</strong>、<strong>布尔值</strong>都是这种值类型数据，而数组是引用类型数据。</p>
<h2 id="引用类型数据"><a class="header" href="#引用类型数据">引用类型数据</a></h2>
<p>再来看一段类似的代码：</p>
<pre><code class="language-gdscript">var a = [1, 2]
var b = a
a.append(10)
print(a)
print(b)
</code></pre>
<p>这段程序会输出两个 <code>[1, 2, 10]</code>。</p>
<p>这是因为数组是引用类型的数据，当执行 <code>var a = [1, 2]</code> 这一行时，变量 a 实际存放的并不是这个数组，而是这个数组的<strong>引用</strong>。</p>
<p>接下来 <code>var b = a</code> 这一行，我们将 a 赋值给 b，实际上就是将<strong>这个数组的引用</strong>赋值给了变量 b，所以，变量 a 和 b 存放的是<strong>同一个数组的引用</strong>。</p>
<p>所以在后续代码中，不论是调用 <code>a.append</code> 还是 <code>b.append</code>，实际上都是对同一个数组进行操作，因此在最后 print 时两个变量输出的其实是同一个数组。</p>
<p>这种引用类型的数据，除了数组外还有很多，例如绝大多数类的实例都是引用类型，自然也就包括各种节点。</p>
<p>所以我们使用 <code>var 输入框1 = $LineEdit</code>，然后 <code>var 输入框2 = 输入框1</code>，实际上这两个输入框变量指向的都是同一个输入框。</p>
<h2 id="null"><a class="header" href="#null">null</a></h2>
<p><code>null</code> 表示没有数据，我们可以写一句 <code>var a = null</code> 来表示变量 a 中什么都不存放。</p>
<p>某些情况下我们会意外的得到一些 null，例如使用 <code>$</code> 获取一个不存在的节点时，它就会返回 null。</p>
<p>记住，<code>null</code> 并不是什么好东西，比如我们执行下面的代码：</p>
<pre><code class="language-gdscript">var 输入框 = $输入框节点名
print(输入框.text)
</code></pre>
<p>如果场景中并没有叫做 <code>输入框节点名</code> 的输入框，<code>输入框</code> 变量就会存放一个 null，此时下一行就出问题了，因为 null 并没有 text 属性，于是我们就得到了一个错误。</p>
<p>所以，当我们不能断定某些操作是否会得到 null 时，一定要使用 if 语句判断一下：</p>
<pre><code class="language-gdscript">var 输入框 = $输入框节点名
if 输入框 == null:
    print(&quot;没获取到输入框&quot;)
else:
    print(输入框.text)
</code></pre>
<blockquote>
<p>这里的 <code>if 输入框 == null</code> 还可以写成 <code>if 输入框 is null</code>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日后再深入"><a class="header" href="#日后再深入">日后再深入</a></h1>
<p>理解面向对象需要一定过程，这一章只是带领各位初步认识一下面向对象的概念，各位需要在学习下一章的过程中逐步理解本章内容。</p>
<blockquote>
<p>Godot 的很多东西如果不会面向对象还不好学，但学面向对象又需要很多编程经验，所以本书尝试将这两部分穿插来讲。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引擎交互"><a class="header" href="#引擎交互">引擎交互</a></h1>
<p>学 GDScript 的最终目的还是 Godot。</p>
<h2 id="学习建议"><a class="header" href="#学习建议">学习建议</a></h2>
<p>某些章节可能会让你感觉云里雾里，这是因为某些内容是互相关联的，可能需要结合后几节的知识才能理解。</p>
<p>所以建议不要因为一小点看不懂就放弃。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期---单次执行周期"><a class="header" href="#生命周期---单次执行周期">生命周期 - 单次执行周期</a></h1>
<p>节点的生命周期是指节点从出生（创建）到死亡（删除）的过程，这个过程中有几个关键的时间点，我们可以在这些时间点编写我们的逻辑代码，承载这些代码的方法就被称为生命周期方法。</p>
<p>我们之前见过 <code>_ready</code> 和 <code>_process</code> 方法，它俩就是两个最常见的生命周期方法。</p>
<blockquote>
<p>[!tip] </p>
<p>生命周期方法不需要我们手动调用，Godot 会在内部自动调用它们。</p>
</blockquote>
<h2 id="_enter_tree"><a class="header" href="#_enter_tree">_enter_tree</a></h2>
<p>这个生命周期方法会在节点进入到场景树时执行，也就是节点出现时执行。</p>
<p>注意不要和下面的 <code>_ready</code> 搞混，在执行 <code>_enter_tree</code> 生命周期方法时可能还没有子节点，因为子节点还没有加入到场景树中。</p>
<h2 id="_ready"><a class="header" href="#_ready">_ready</a></h2>
<p>当节点完全准备好时执行。</p>
<p>完全准备好是指子节点都执行完毕 <code>_ready</code> 和 <code>_enter_tree</code> 方法，并且当前节点执行完 <code>_enter_tree</code> 方法。</p>
<h2 id="区分-_enter_tree-和-_ready"><a class="header" href="#区分-_enter_tree-和-_ready">区分 _enter_tree 和 _ready</a></h2>
<p>假设现在有一个这样的场景：</p>
<pre><code>Control
    LineEdit
    TextureRect
</code></pre>
<p>其中 Control 节点有两个子节点，分别是 LineEdit 和 TextureRect，并给他们三个都加上相同的脚本：</p>
<pre><code class="language-gdscript">extends Node

func _enter_tree():
    # name 是指节点的名字
    print (name + &quot; enter tree&quot;)

func _ready():
    print (name + &quot; ready&quot;)
</code></pre>
<p>运行场景后，我们会看到这样的输出结果：</p>
<pre><code>Control enter tree
LineEdit enter tree
TextureRect enter tree
LineEdit ready
TextureRect ready
Control ready
</code></pre>
<p>可见 <code>_enter_tree</code> 会最先执行，且父节点优先执行，而 <code>_ready</code> 最后执行，且父节点排在最后。</p>
<h2 id="_exit_tree-节点离开场景树"><a class="header" href="#_exit_tree-节点离开场景树">_exit_tree 节点离开场景树</a></h2>
<p>顾名思义，当节点离开场景树时执行，且子节点优先执行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期---循环执行周期"><a class="header" href="#生命周期---循环执行周期">生命周期 - 循环执行周期</a></h1>
<p>上一节认识的生命周期每个节点只会触发一次，下面这两个周期方法会在节点存在时反复执行。</p>
<h2 id="_process"><a class="header" href="#_process">_process</a></h2>
<p>我们都知道游戏画面是一帧一帧显示的，那这个 <code>_process</code> 就是每个画面帧时执行了。</p>
<p>这个方法还需要有个参数，Godot 给的默认参数名是 <code>delta</code>，它表示当前帧和上一帧之间间隔的时长，单位是秒。</p>
<h2 id="_physics_process"><a class="header" href="#_physics_process">_physics_process</a></h2>
<p>类似画面帧，游戏中进行物理效果模拟时也是一帧一帧进行的，不过这个帧不等于画面帧，Godot 默认是每秒 60 物理帧，同样他也有个 <code>delta</code> 参数，表示上一个物理帧与当前物理帧之间的间隔时长。</p>
<h2 id="画面帧和物理帧"><a class="header" href="#画面帧和物理帧">画面帧和物理帧</a></h2>
<p>画面帧和物理帧就是指 <code>_process</code> 和 <code>_physics_process</code>。</p>
<p>当我们处理一些画面显示相关的逻辑，例如按钮动画、视角移动等，建议使用 <code>_process</code>，这能保证每次画面刷新时都能看到流畅的画面变化。</p>
<p>如果要处理一些物理相关的逻辑，例如玩家移动、开门关门等，一定要使用 <code>_physics_process</code>，因为物理碰撞、摩擦等运算都是在物理帧进行的，如果某个物体在画面帧中移动，可能会导致物理帧中处理不到这次移动信息，从而影响物理模拟的真实性。</p>
<h2 id="delta"><a class="header" href="#delta">delta</a></h2>
<p>两个 process 生命周期都有个 <code>delta</code> 参数，使用这个方法可以平衡不同帧率对游戏的影响。</p>
<p>例如现在我有一个配置极高的电脑，可以保证 <code>_physics_process</code> 方法每秒执行 60 次，而你的电脑比较垃圾，只能保证 <code>_physics_process</code> 方法每秒执行 30 次。</p>
<p>然后这个游戏里有一段这样的代码：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
    position.x += 1
</code></pre>
<p>很明显，我会每秒移动 60 单位，因为我的电脑在一秒钟内执行了 60 次 <code>_physics_process</code>，而你一秒钟只能移动 30 次。</p>
<p>这时结合 delta 参数，让上面的代码变成：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
    position.x += 60 * delta
</code></pre>
<p>这时，由于 delta 有“电脑越差数值越高”的特点，修改后的代码可以保证咱俩每秒都能移动 60 的单位。</p>
<blockquote>
<p>[!note] 常用生命周期</p>
<p>最常用的生命周期就这三个： <code>_ready</code> <code>_process</code> <code>_physics_process</code>。</p>
<p>熟练掌握这三个生命周期即可实现绝大多数效果。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取输入-1"><a class="header" href="#获取输入-1">获取输入</a></h1>
<p>Godot 给我们预先写好了很多类，这其中有一个 <code>Input</code> 类专门用于获取玩家的输入信息。</p>
<p>先来介绍一个最简单的方法，<code>is_key_pressed</code>，它可以判断一个按键是否被按住，例如实现一个按 w 键向上移动：</p>
<pre><code class="language-gdscript">func _physics_process(delta):
    if Input.is_key_pressed(KEY_W):
        position.y -= 1000 * delta
</code></pre>
<p>因为涉及到移动，所以我们把这段代码放到了 <code>_physics_process</code> 生命周期方法中。</p>
<p>根据 <code>is_key_pressed</code> 这个名字可以看出来，他是判断按键是否被按下的，也就是说这个方法的返回值是布尔类型，当按键被按下时返回 true，没按下时返回 false。它的参数是一个 KeyCode 类型的枚举，什么是枚举可以先不用考虑，总之这个参数应该是你想检测的按键，而 Godot 定义了一堆 <code>KEY_???</code> 这样的变量来表示每一个按键，上面代码中使用的 <code>KEY_W</code> 就表示了键盘上的 W 键。</p>
<p><code>is_key_pressed</code> 结合 <code>if</code> 语句，就实现了<strong>当玩家按下某个键时执行一段代码</strong>这样的逻辑，这里当按下 W 时就会执行向上移动，也就是 <code>position.y -= 1000 * delta</code>。</p>
<blockquote>
<p>关于 position 和 delta 分别在 <a href="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92//Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.html#delta">生命周期2</a> 和 <a href="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92//Part-%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%B1%BB%E6%88%90%E5%91%98.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1">类成员</a> 小节讲过。</p>
</blockquote>
<h2 id="输入映射"><a class="header" href="#输入映射">输入映射</a></h2>
<p>大部分游戏都支持多种输入方式，例如一般的主机游戏都支持键鼠和手柄，虽然我们可以使用 or 运算同时判断多个按键输入，但这必定会很麻烦。</p>
<p>现在的绝大多数游戏都会有一个这样的界面：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/cs_keyboard.png" alt="cs的键位设置界面" /></p>
<p>在这种地方，游戏定义了例如移动、跳跃等动作。在代码中直接判断玩家是否进行了某种动作即可，Godot 也为我们提供了一个这样的东西。</p>
<p>打开引擎主界面菜单中的<code>项目</code> -&gt; <code>项目设置</code> -&gt; <code>输入映射</code> 选项卡，即可看到类似上图的界面，我们可以在这里添加咱们的按键映射，例如：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/input.png" alt="输入映射" /></p>
<p>在代码中，我们可以使用 <code>Input.is_action_pressed(&quot;动作名称&quot;)</code> 来获取某个动作对应的按键是否被按下，例如我们要检测上图中的 Fire 动作：</p>
<pre><code class="language-gdscript">if Input.is_action_pressed(&quot;Fire&quot;):
    print(&quot;按下了 Fire 键！&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线性输入"><a class="header" href="#线性输入">线性输入</a></h1>
<p>游戏手柄上有一些可以“输入一半”的键，比如摇杆和扳机，这时候就可以使用 <code>Input.get_action_strength(&quot;动作名称&quot;)</code> 来获取一个小数数值，范围是 0 ~ 1，表示按键移动的强度。</p>
<p>例如根据玩家向左移动摇杆的幅度控制移动速度：</p>
<pre><code class="language-gdscript">var left = Input.get_action_strength(&quot;动作名称&quot;)
if left &gt; 0:
    position.x -= left * delta * 1000
</code></pre>
<h2 id="成对输入"><a class="header" href="#成对输入">成对输入</a></h2>
<p>有时候我们会需要成对的输入，例如操控船只的加速和减速，我们可以使用 <code>Input.get_axis(&quot;反方向动作&quot;,&quot;正方向动作&quot;)</code> 来获取一个 -1 ~ 1 的值。</p>
<p>或者有些两个轴的输入，例如玩家的上下左右移动，可以使用 <code>Input.get_vector(&quot;-x动作&quot;,&quot;+x动作&quot;,&quot;-y动作&quot;,&quot;+y动作&quot;)</code> 来获取到一个 Vector2 类型的值，其中的 x 和 y 的范围是 -1 ~ 1。</p>
<p>这两个方法没什么难点，这里就不放示例了，各位亲自体验尝试以下吧。</p>
<blockquote>
<p>[!tip]</p>
<p>这些返回小数的输入获取方法，对于键盘或非线性按键的操作会返回 -1、0、1 这种整数值。</p>
</blockquote>
<h2 id="鼠标输入"><a class="header" href="#鼠标输入">鼠标输入</a></h2>
<p>鼠标的按键输入可以直接使用输入映射功能。</p>
<p>如果要获取鼠标的位置，则可以使用 <code>get_global_mouse_position()</code> 获取鼠标在 2D 世界中的坐标。</p>
<p>如果要获取鼠标的移动速度，则需要使用 <code>_input</code> 生命周期方法：</p>
<pre><code class="language-gdscript">func _input(event):
    if is_instance_of(event,InputEventMouseMotion):
        print(event.velocity)
</code></pre>
<p>这样就会输出鼠标的移动速度。</p>
<blockquote>
<p>这段代码涉及到一些没学过的东西，暂时先不解释了，暂时只要知道里面的 if 中的代码会在鼠标移动时执行即可。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活玩家移动"><a class="header" href="#整活玩家移动">整活：玩家移动</a></h1>
<p>终于来到了一个整活章节，本章的整活章节将共同制作一个小游戏，玩起来大概这样：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/game.gif" alt="引擎交互章节整活游戏预览" /></p>
<p>本节咱们运用刚刚学习过的生命周期方法和获取输入来实现玩家的移动。</p>
<h2 id="玩家节点创建"><a class="header" href="#玩家节点创建">玩家节点创建</a></h2>
<p>我们的主角需要具有上下左右移动的能力，并且我们不希望他能穿透障碍，因此我们选择 <code>RigidBody2D</code> 作为玩家的根节点，子节点则是玩家的碰撞体和显示玩家图片用的精灵：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/game1_player_node.png" alt="玩家节点" /></p>
<p>此时需要注意以下几点：</p>
<ul>
<li>
<p>Godot 中的 0 度表示向右，因此这里的玩家默认向右看。</p>
</li>
<li>
<p>咱的游戏是俯视视角的，而 Godot 的 RigidBody2D 节点自带一个向下的重力，因此需要给 RigidBody2D 的 GravityScale 属性设置为 0 以取消重力。</p>
</li>
<li>
<p>CollisionShape2D 节点需要指定一个碰撞形状，也就是 Shape 属性，这里使用的是 CircleShape2D 形状，如果你还不太了解这些节点的使用，可以自己试着多点一点，界面操作肯定是比学习代码简单的。</p>
</li>
</ul>
<h2 id="代码编写"><a class="header" href="#代码编写">代码编写</a></h2>
<p>移动玩家的代码肯定是要写在玩家最外层的节点了，具体的代码如下：</p>
<pre><code class="language-gdscript">extends RigidBody2D

var 移动速度: int = 200

func _physics_process(delta):
    var 移动输入 := Input.get_vector(&quot;左&quot;, &quot;右&quot;, &quot;上&quot;, &quot;下&quot;)
    if 移动输入.length() &gt; 0:
        move_and_collide(移动输入 * delta * 移动速度)

func _process(delta):
    var 鼠标方向 = get_global_mouse_position() - global_position
    rotation = 鼠标方向.angle()
</code></pre>
<p>其中 <code>_physics_process</code> 方法中先获取了玩家移动的按键输入，并保存到一个二维向量中，若该向量的长度为 0，则表示玩家没有输入，所以当输入不为 0 时调用 <code>move_and_collide</code> 方法进行移动。</p>
<p><code>_process</code> 方法中使用 <code>get_global_mouse_position</code> 方法获取鼠标的坐标，并减去当前玩家的全局坐标，这样就得到了一个从玩家指向鼠标的方向向量，并存放到 <code>鼠标方向</code> 变量中。随后将这个方向的角度赋值给玩家的旋转角度（rotation 变量）。</p>
<blockquote>
<p>[!tip]</p>
<p>移动行为涉及到障碍物碰撞等物理效果，所以移动逻辑被放在了 <code>_physics_process</code> 方法中，而在本游戏中的玩家旋转行为不涉及物理效果，所以放在了 <code>_process</code> 方法中，当你在制作自己的游戏时需要根据游戏需求选择不同的生命周期方法。</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p>思考一个小问题，现在的玩家垂直向下的移动速度和向右下方斜向移动的速度相同吗？尝试使用 <code>print(移动输入)</code> 看一看吧。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packedscene实例化"><a class="header" href="#packedscene实例化">PackedScene实例化</a></h1>
<p>某些物品会在游戏中反复出现，以玩家发射的炮弹举例，炮弹可以被反复创建，且每颗炮弹都几乎相同，那么我们就可以制作一个炮弹模板，在玩家开火时创建它。</p>
<p>这个 <code>PackedScene</code> 就是模板，这俩单词翻译成中文是 <code>打包的场景</code>，也就是说模板的本质就是场景，也就是任意一个节点（及其子节点）。</p>
<blockquote>
<p>如果学过 Unity，其实这个 PackedScene 就等于 Unity 的预制体。</p>
</blockquote>
<h2 id="创建-packedscene"><a class="header" href="#创建-packedscene">创建 PackedScene</a></h2>
<p>方法有三：</p>
<ol>
<li>
<p>点击菜单栏[场景] -&gt; [新建场景]后，开始制作你的模板，并保存当前场景。</p>
</li>
<li>
<p>在任意场景对着节点列表中的某个节点右键，点击 [将分支保存为场景]。</p>
</li>
<li>
<p>在节点列表中拖拽节点到下面的文件列表中。</p>
</li>
</ol>
<blockquote>
<p>Godot 中的一个场景就是个 PackedScene</p>
</blockquote>
<h2 id="生成-packedscene"><a class="header" href="#生成-packedscene">生成 PackedScene</a></h2>
<p>想要把一个 PackedScene 使用代码创建出来，就需要先在代码中获取到 PackedScene 这个文件。</p>
<p>使用 <code>load(&quot;文件路径&quot;)</code> 来读取一个 Godot 资源，这里的文件路径使用 <code>res://</code> 开头表示项目中的资源。</p>
<p>假如咱们把某个 PackedScene 保存到了项目中的 <code>物体</code> 文件夹，例如这样：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/packed_in_res.png" alt="PackedScene" /></p>
<p>在代码中我们使用 <code>load(&quot;res://物体/某个packed_scene.tscn&quot;)</code> 即可获取到这个 PackedScene。</p>
<p>当我们想要根据这个 PackedScene 创建新物体时，可以调用它的 <code>instantiate</code> 方法，这个方法会返回创建好的节点。</p>
<p>现在我们来看下完整流程：</p>
<pre><code class="language-gdscript">var 保存好的场景 = load(&quot;res://物体/某个packed_scene.tscn&quot;)
var 新物体 = 保存好的场景.instantiate()
get_parent().add_child(新物体)
</code></pre>
<p>最后一句的 <code>get_parent()</code> 会获取当前节点的父节点，然后我们又调用了父节点的 <code>add_child</code> 方法，<code>add_child</code> 方法会给节点添加新的子节点，所以最后这一整行就是把<code>新物体</code>变成了与代码所在节点自身同级的节点。</p>
<blockquote>
<p>[!tip] </p>
<p>instantiate() 只是把节点创建来出来，但还没有添加到场景中，所以是看不到的。</p>
<p>配合 add_child 才能真正创建一个新物体。</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p>PackedScene 中的节点不能与外部的节点存在信号连接，比如 PackedScene 中某个按钮的信号不能连接到 PackedScene 外面的脚本上，毕竟在 Godot 眼中，她不知道这个 PackedScene 被创建出来的时候外面的脚本是否存在。</p>
<p>但是 PackedScene 内部的信号连接是没有问题的。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="节点操作"><a class="header" href="#节点操作">节点操作</a></h1>
<p>Godot 使用节点作为组成游戏物体的基本单位，因此操作节点就等于操作游戏中的物体。</p>
<blockquote>
<p>注意哈，本节是讲操作节点，而不是操作节点上的属性</p>
</blockquote>
<p>我们上一节见到了 <code>get_parent</code> 和 <code>add_child</code> 方法，这一节我们多认识几个操作节点的方法。</p>
<h2 id="获取节点"><a class="header" href="#获取节点">获取节点</a></h2>
<p>我们之前见到过 <code>$xxx</code> 这种写法，其实有一个和它功能相同的方法，叫做 <code>get_node</code>，不过 <code>$</code> 符号用起来更方便，所以基本上很少会用 <code>get_node</code>。</p>
<p><code>$节点名</code> 这种写法大家应该都认识，就是获取子物体中叫做 <code>节点名</code> 的那个节点。</p>
<p>节点名可能包含一些奇怪的符号，直接把名字写在 $ 后面会出现语法错误，比如有个节点叫做 <code>外.币 巴-伯</code>，这时就可以使用字符串来表示节点名，变成 <code>$&quot;外.币 巴-伯&quot;</code> 即可。</p>
<p>准确来说，$ 符号后面填写的并不是节点名，而是节点路径，例如我们可以使用两个点 <code>..</code> 表示上一级，或者使用 <code>/root/</code> 开头表示场景根节点，下面来看几个例子：</p>
<ul>
<li>
<p><code>$&quot;../ABC&quot;</code> 获取和当前脚本所在节点同级的 ABC 节点</p>
</li>
<li>
<p><code>$&quot;../../../&quot;</code> 获取自己的父节点的父节点的父节点</p>
</li>
<li>
<p><code>$&quot;/root/BFG&quot;</code> 获取场景中最外层的 BFG 节点</p>
</li>
</ul>
<h2 id="添加节点"><a class="header" href="#添加节点">添加节点</a></h2>
<p>添加节点其实就是 <code>add_child</code> 方法，调用哪个节点的 <code>add_child</code> 就是给那个节点添加子节点。</p>
<p>例如 <code>$ABC.add_child(新节点)</code> 就是给 ABC 节点添加子节点。</p>
<h2 id="删除节点"><a class="header" href="#删除节点">删除节点</a></h2>
<p>删除节点有两个方法：<code>free</code> 和 <code>queue_free</code>。</p>
<p>一般情况下我更建议使用 <code>queue_free</code> 来删除节点，方法名中的 queue 是队列的意思，可以理解成排队，也就是说这是让节点排队删除，而不是立刻删除。</p>
<p>而 <code>free</code> 则是立刻删除节点，在调用 <code>free</code> 时，Godot 就会立刻删除这个节点。</p>
<p>我们来看个例子：</p>
<pre><code class="language-gdscript"># 这是举例用的错误代码
free()
print(position)
</code></pre>
<p>运行这段代码游戏会报错，因为执行 <code>free</code> 时就会立刻删除这个节点，而下面的代码要输出 position 这个位置属性，可是节点已经被删除了，哪里还有位置呢。</p>
<p>如果我们将 <code>free</code> 换成 <code>queue_free</code> 则可以避免这个报错，Godot 会先将调用 <code>queue_free</code> 的节点记录下来，等咱们的代码执行完毕后，在空闲时间时再将它们删除。</p>
<blockquote>
<p>某些生命周期或信号中使用 free 会直接报错，因为 Godot 内部有一种节点锁定机制。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活fire"><a class="header" href="#整活fire">整活：Fire</a></h1>
<p>本节实现玩家开火效果。</p>
<p>首先需要创建一个子弹的 PackedScene，由于玩家的子弹可以与其他物体产生碰撞，因此我们使用 Area2D 作为子弹的根结点：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/bullet.png" alt="子弹PackedScene" /></p>
<blockquote>
<p>最后那个 Timer 节点在本节最后讲解</p>
</blockquote>
<p>子弹具有&quot;飞行&quot;能力，但飞行的方向是不固定的，需要根据玩家开火时的朝向确定，所以我们在子弹的代码中定义一个 <code>移动速度</code> 属性，当玩家发射子弹时由玩家来对这个属性赋值。</p>
<p>子弹的代码如下：</p>
<pre><code class="language-gdscript">extends Area2D
class_name 子弹类

var 移动速度:Vector2

func _physics_process(delta):
    position += 移动速度 * delta
</code></pre>
<p>对应的，再给之前的玩家移动脚本添加上射击相关的逻辑：</p>
<pre><code class="language-gdscript">var 子弹: PackedScene

func _ready():
    # 获取子弹的 PackedScene
    子弹 = load(&quot;res://子弹/子弹.tscn&quot;)

func _process(delta):
    var 鼠标方向 = get_global_mouse_position() - global_position
    rotation = 鼠标方向.angle()
    if Input.is_action_just_pressed(&quot;攻击&quot;):
        var 创建的子弹:子弹类 = 子弹.instantiate()
        创建的子弹.移动速度 = 鼠标方向.normalized() * 1000
        $&quot;/root/&quot;.add_child(创建的子弹)
        创建的子弹.global_position = global_position
        创建的子弹.rotation = 鼠标方向.angle()
</code></pre>
<blockquote>
<p><code>鼠标方向.normalized()</code> 可以把向量归一化，以此来去除鼠标位置对子弹速度的影响。</p>
</blockquote>
<h2 id="子弹清理"><a class="header" href="#子弹清理">子弹清理</a></h2>
<blockquote>
<p>[!tip]</p>
<p>涉及到信号指示，可以先阅读 <a href="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./%E4%BF%A1%E5%8F%B7.html">信号</a> 章节。</p>
</blockquote>
<p>如果你发射了太多子弹，例如100000发，当子弹飞出屏幕后，即便我们再也见不到它，但它仍然在我们的视野之外飞行，这会对电脑产生不小的压力。</p>
<p>因此我们需要删除掉一些&quot;没有用&quot;的子弹，这里我给子弹添加了一个定时器节点（Timer 节点），它将在子弹被创建的 10 秒后触发 timeout 信号：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/bullet_timer.png" alt="定时器属性" /></p>
<p>将 timeout 信号连接到子弹脚本中即可实现定时删除：</p>
<pre><code class="language-gdscript">func _on_timer_timeout():
    queue_free()
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>根据时间清理子弹不是唯一的手段，例如还可以根据子弹的位置来清理，或是子弹的移动距离等，你可以试着自己实现下其他的清理方式。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号"><a class="header" href="#信号">信号</a></h1>
<p>有一种编程方式叫做“事件驱动式编程”，大意就是说当发生某件事的时候就执行一段代码，以此来实现整个程序的功能。其中的<strong>事件</strong>在 Godot 中被称作<strong>信号</strong>。</p>
<p>一个信号可以连接到很多方法，当信号触发时则会执行这些方法。</p>
<blockquote>
<p>你也可以把信号理解成一组方法的集合，并且可以同时调用这组方法。</p>
</blockquote>
<p>我们之前接触过按钮节点（Button）的 pressed 方法，这是按钮被按下的信号，不同的节点有不同的信号，例如输入框节点（LineEdit）有 text_changed 信号，会在内容发生变化时触发，且还包含一个参数。</p>
<h2 id="连接信号"><a class="header" href="#连接信号">连接信号</a></h2>
<p>在 Godot 引擎界面中可以双击信号来连接到某个脚本上的方法，这种操作没什么难度，这里不再讲解。我们重点看看使用代码连接信号。</p>
<p>我们来尝试实现一个这样的效果：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/add3.gif" alt="+3" /></p>
<p>场景中包含三个节点：</p>
<pre><code>Control
    Button
    Label
</code></pre>
<p>我们将脚本写在了 Control 节点上：</p>
<pre><code class="language-gdscript">extends Control

func _ready():
    $Button.pressed.connect(当点击按钮)

func 当点击按钮():
    $Label.text = str(int($Label.text) + 3)
</code></pre>
<p>重点就是 _ready 方法中的 <code>$Button.pressed.connect(当点击按钮)</code>，其中的 pressed 属性就是按钮的 pressed 信号，信号对象有 connect 方法，这个方法的参数也是一个方法，表示将信号连接到方法上。</p>
<blockquote>
<p>connect 这个单词的中文翻译：连接</p>
</blockquote>
<h2 id="断开连接"><a class="header" href="#断开连接">断开连接</a></h2>
<p>调用信号的 disconnect 方法就可以断开某个与方法的连接：</p>
<pre><code class="language-gdscript">$Button.pressed.disconnect(当点击按钮)
</code></pre>
<blockquote>
<p>[!tip] 代码自动补全没了？</p>
<p>个人感觉目前的 Godot 编辑器有时候有点小问题，我的 Godot 在输入 <code>$Button.pressed.</code> 后不会弹出 pressed 的属性提示，这种情况对于新人来讲属于是个灾难。</p>
<p>这时候，强类型语法就可以登场了，可以用一些拐弯的方法来得到代码提示：</p>
<pre><code class="language-gdscript">var 点击信号: Signal = $Button.pressed
点击信号.connect(当点击按钮)
</code></pre>
<p>这样，在输入 <code>点击信号.</code> 的时候就能看到信号对象的代码提示了，这里使用的类型 Signal 就是信号类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组"><a class="header" href="#组">组</a></h1>
<p>Godot 中的组，作用是给节点打标签。</p>
<p>在游戏中，某些东西会被归为一类，例如 Minecraft 中的僵尸和骷髅是“亡灵生物”，蜘蛛和烈焰人是“节肢生物”，在使用高级的武器攻击它们时会产生不同的效果。对于代码来讲，当武器击中怪物时就需要判断敌人的种类，从而造成不同的伤害。</p>
<p>选中一个节点后，在屏幕右边的<strong>节点</strong>选项卡的<strong>分组</strong>页面中即可给节点分配组，例如现在创建一个僵尸节点：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/group.png" alt="添加组" /></p>
<p>这样，节点就加入了一个组。</p>
<blockquote>
<p>组不用手动创建，但如果你想要更好的管理组，可以试试点<strong>管理分组</strong>按钮。</p>
</blockquote>
<h2 id="判断组"><a class="header" href="#判断组">判断组</a></h2>
<p>来到代码中，我们可以使用节点对象的 <code>is_in_group</code> 方法判断节点是否属于某个组，例如在刚刚的场景中，我们在根节点中加入下面代码：</p>
<pre><code class="language-gdscript">func _ready():
    print($Zombie.is_in_group(&quot;亡灵生物&quot;))
</code></pre>
<p>这就会输出一个 <code>true</code>。</p>
<h2 id="代码操作组"><a class="header" href="#代码操作组">代码操作组</a></h2>
<p>虽然应该不常用，但如果你想要使用代码操纵节点的组，可以使用 <code>add_to_group</code> 方法把节点添加到一个组中，或使用 <code>remove_from_group</code> 从组中移除节点：</p>
<pre><code class="language-gdscript">$Zombie.remove_from_group(&quot;亡灵生物&quot;)
$Zombie.add_to_group(&quot;怪物&quot;)
print($Zombie.is_in_group(&quot;亡灵生物&quot;)) # 输出 false
print($Zombie.is_in_group(&quot;怪物&quot;)) # 输出 true
</code></pre>
<p>还有个 <code>get_groups</code> 方法可以获取节点的全部组，考虑到一般用不到，此处不再展示。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活靶子"><a class="header" href="#整活靶子">整活：靶子</a></h1>
<p>本节来添加靶子，这是一个可以被子弹攻击到的物体，并且会阻碍玩家移动，因此使用 StaticBody2D 作为靶子的根结点：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/target.png" alt="靶子节点" /></p>
<p>靶子的唯一用途就是被子弹攻击，因此靶子自身不用编写任何方法。</p>
<p>要做到子弹攻击靶子，我们需要修改子弹脚本，利用子弹根结点 Area2D 的 <code>body_entered</code> 信号，我们可以在子弹碰到某个物理节点（例如 StaticBody2D）时做一些处理。</p>
<p>连接子弹根结点的 <code>body_entered</code> 信号到子弹脚本上，并且写下如下代码：</p>
<pre><code class="language-gdscript">func _on_body_entered(body:PhysicsBody2D):
    if body.is_in_group(&quot;靶子&quot;):
        body.queue_free()
        queue_free()
</code></pre>
<p>其中的第一个 if 判断碰到的节点是否在 <code>靶子</code> 组中，所以不要忘了给靶子节点添加到这个组中。if 里面的两行代码就分别是删除靶子和子弹。</p>
<blockquote>
<p>[!tip]</p>
<p>我们也可以选择在靶子上编写逻辑，进行&quot;靶子是否碰到子弹&quot;的判断，但一般我们的认知应该是&quot;子弹攻击靶子&quot;，所以我习惯把这个判定放到子弹身上。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性导出"><a class="header" href="#属性导出">属性导出</a></h1>
<p>选中一个节点后，我们可以在屏幕右边看到好多节点的属性，其实我们也可以在这里添加自己的属性。</p>
<p>给咱们脚本中的属性变量加上 <code>@export</code> 前缀即可：</p>
<pre><code class="language-gdscript">@export var 玩家名: String = &quot;没名字吗？&quot;
@export var 钱包: int = 5

func _ready():
    # 注意，成员变量是指脚本最外层的变量，不要定义在方法里面！
    pass
</code></pre>
<p>给节点加上上面代码后，即可在属性面板看到效果：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/export.png" alt="导出的属性" /></p>
<p>定义变量时指定的初始值就是面板上的默认值，在面板上修改属性值后也就等于修改变量的值。大家可以修改后利用 print 语句试试效果。</p>
<blockquote>
<p>[!tip]</p>
<p>Godot 会根据属性变量的类型提供不同的输入框，例如 Color 类型会提供颜色选择器，PackedScene 类型则会让你选择一个保存的场景。</p>
<p>很多时候，属性导出可以代替掉 load 方法。</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p><code>@export var 哈</code> 这样的属性是不能导出的，因为 Godot 不知道这个变量是个什么类型，也就不知道应该在面板上显示什么样的输入框，所以这种属性变量必须使用强类型指定类型或指定上初始值。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活分数"><a class="header" href="#整活分数">整活：分数</a></h1>
<p>我们可以让游戏更有趣一些，让玩家在击中靶子时增加一些分数，且不同的靶子分数不同。</p>
<p>首先实现一点：不同靶子分数不同。现在给靶子添加一个脚本，脚本中仅需要一句代码：</p>
<pre><code class="language-gdscript">@export var 分数: int = 1
</code></pre>
<p>这样，当我们创建多个靶子时（建议用 PackedScene），即可在引擎中任意修改某一个靶子的分数了。</p>
<p>通常在一个完整的游戏中会有单独的部分存储全局信息，但我们的游戏比较简单，我就将分数变量存放到玩家实例上了，也就是给玩家添加一个属性：</p>
<pre><code class="language-gdscript">var 分数: int = 0
</code></pre>
<p>为了显示分数，我们在创建几个节点来组成 ui 界面：</p>
<p><img src="Part-%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92/./images/score_ui.png" alt="分数UI" /></p>
<p>把上述 ui 节点添加到场景中后，接着修改子弹击中靶子后的代码：</p>
<pre><code class="language-gdscript">if body.is_in_group(&quot;靶子&quot;):
    # 玩家的现有分数加上靶子的价值分数
    $&quot;/root/Game/玩家&quot;.分数 += body.分数
    
    # 更新 ui 界面
    $&quot;/root/Game/UI/分数&quot;.text = &quot;得分：&quot; + str($&quot;/root/Game/玩家&quot;.分数)

    body.queue_free()
    queue_free()
</code></pre>
<p>完成</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入面向对象"><a class="header" href="#深入面向对象">深入面向对象</a></h1>
<p>别看我们目前学的东西还不多，但其实已经可以实现很多的游戏效果了。</p>
<p>在学习这一章之前，请确保自己已经熟练掌握了前面的章节，并且建议尝试写一些小游戏。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字典"><a class="header" href="#字典">字典</a></h1>
<p>正式进入面向对象之前，我们先来学习一个新的数据类型：<strong>字典</strong>（<code>Dictionary</code>）。</p>
<p>字典使用键值对存储数据，键值对是指一个键和一个值组成的一对数据，例如 <code>我的名字是 Rika</code> 这句话中，<code>我的名字</code> 就是键，<code>Rika</code> 是值。</p>
<p>让我们回顾一下数组，GDScript 的数组由方括号 <code>[</code> 和 <code>]</code> 包裹，其中填入很多元素并用逗号 <code>,</code> 分隔。</p>
<p>字典的语法也类似，不过是使用花括号 <code>{</code> 和 <code>}</code> 包裹起来，其中填入很多键值对，键值对之间也用逗号 <code>,</code> 分隔。至于键值对，则是两个数据之间用冒号 <code>:</code> 分隔。</p>
<p>例如存一个玩家信息：</p>
<pre><code class="language-gdscript">var 玩家信息: Dictionary = {
    &quot;名字&quot;: &quot;Rika&quot;,
    &quot;年龄&quot;: 22,
    &quot;职业&quot;: &quot;赤魔法师&quot;,
}
</code></pre>
<p>其中的 名字、年龄、职业 就是键，每个冒号后面的就是值。</p>
<p>注意一点，键值对的键和值都是数据，所以 名字、年龄、职业 这些键都是一个字符串，不能是变量那种直接写的名字。</p>
<p>获取元素值的方式也很类似数组，方括号里直接填写键即可，例如显示玩家名字：</p>
<pre><code class="language-gdscript">print(玩家信息[&quot;名字&quot;])
</code></pre>
<h2 id="动态键"><a class="header" href="#动态键">动态键</a></h2>
<p>字典有什么有点呢，我们也可以直接写三个变量分别存储 名字、年龄、职业 对吧？</p>
<p>动态的元素是字典的一大特点，就类似数组，我们可以随时向里面添加或删除数据，而变量则需要提前声明好。</p>
<p>由于字典元素不确定，所以不能随意从中取值，例如在上面的代码中运行 <code>print(玩家信息[&quot;啥&quot;])</code> 就会得到一个错误。</p>
<p>如果不能保证某个键是否存在，可以使用 <code>in</code> 关键字（或者叫运算符）进行判断，<code>in</code> 的左边是键，右边是字典，结合 if 关键字：</p>
<pre><code class="language-gdscript">if &quot;武器&quot; in 玩家信息:
    print(&quot;玩家手持 &quot; + 玩家信息[&quot;武器&quot;])
else:
    print(&quot;玩家没有武器&quot;)
</code></pre>
<p>这样的 <code>if xxx in xxx</code> 即可判断字典是否包含某个键。</p>
<p>如果只是简单的获取值，每次都加这个 <code>if xxx in</code> 也太麻烦了，所以 GDScript 为字典对象提供了一个方法，叫做 <code>get</code>。</p>
<pre><code class="language-gdscript">print(玩家信息.get(&quot;名字&quot;))
# 等同于
print(玩家信息[&quot;名字&quot;])
</code></pre>
<p>如果玩家信息中不包含名字键，则 get 方法会返回一个 <code>null</code>，而 <code>[&quot;名字&quot;]</code> 索引则会报错并停止游戏。</p>
<p>同时，get 方法的第二个参数可以指定一个默认值，若键不存在，则返回这个默认值：</p>
<pre><code class="language-gdscript">print(玩家信息.get(&quot;名字&quot;, &quot;无名&quot;))
</code></pre>
<p>上例代码中，若 <code>玩家信息</code> 中不包含 <code>名字</code> 键，则输出 <code>无名</code> 二字。</p>
<h2 id="增加删除"><a class="header" href="#增加删除">增加、删除</a></h2>
<p>若要向字典中添加数据，直接使用元素赋值语句即可：<code>玩家信息[&quot;武器&quot;] = &quot;小棍子&quot;</code>。如果字典中存在武器键，则会修改对应的值，若没有武器键则会创建这个键并赋值。</p>
<p>若要删除，则调用 <code>erase</code> 方法并传入一个键，例如 <code>玩家信息.erase(&quot;武器&quot;)</code> 就会删除武器键值对。</p>
<blockquote>
<p>[!note]</p>
<p>字典和数组一样，是<strong>引用类型</strong>数据！</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p>或许你有概率在其他的资料中看到这样的字典写法：</p>
<pre><code class="language-gdscript">var 玩家信息 = {
    名字 = &quot;Rika&quot;,
    年龄 = 22,
    职业 = &quot;赤魔法师&quot;
}
print(玩家信息.名字)
</code></pre>
<p>看起来和咱们学的不太一样，不过本质逻辑还是一样的，这是 GDScript 支持的另一种字典语法，但是由于流行度不如本节重点介绍的那种，因此仅作为了解即可。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="脚本与类"><a class="header" href="#脚本与类">脚本与类</a></h1>
<p>回想之前，我们学习过类的基本概念，如果印象不太清晰的话可以回看 <a href="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/../Part-%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Start.html">认识面向对象</a> 章节。</p>
<p>当时我们说过，写在节点上的脚本就是一个类，我们使用一个让玩家左右移动的脚本作为例子：</p>
<pre><code class="language-gdscript">extends Node2D

var 移动速度: int = 100

func _physics_process(delta):
    var 移动 := 获取横向移动()
    if 移动 != 0:
        position.x += 移动 * delta * 移动速度

func 获取横向移动() -&gt; int:
    if Input.is_action_pressed(&quot;Left&quot;):
        return -1
    if Input.is_action_pressed(&quot;Right&quot;):
        return 1
    return 0
</code></pre>
<p>上述代码就是一个类，这个类中声明了一个 <code>移动速度</code> 属性和 <code>获取横向速度</code> 方法，并在 <code>_physics_process</code> 方法中实现了左右移动的逻辑。</p>
<p>我们现在把这个脚本放到一个节点上，构成这样的场景：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/class1.png" alt="玩家场景" /></p>
<p>现在我们来实现一个效果：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/move1.gif" alt="变速移动" /></p>
<p>如上图，我们可以使用一个滑动条来修改玩家速度，按照传统做法，我们可以把滑动条的数值更改信号 <code>value_changed</code> 连接到玩家脚本上的某个方法，并在其中修改玩家的 <code>移动速度</code> 属性。</p>
<p>但在复杂的游戏中，可能有多种因素影响玩家的移动速度，例如 游戏的地形、玩家负重、负面效果 等，如果都使用信号连接那肯定会特别麻烦，因此我们需要尝试一种直接修改玩家移动速度的方法。</p>
<p>现在我复制一段第二章中“变量”小节中的一句话：<strong>当变量放在方法外面，表示这个变量属于当前节点</strong>。现在我们知道这样的变量就是属性，但注意<strong>这个变量属于当前节点</strong>这几个字，这就表示，当其他的代码获取到玩家节点时，就可以通过这个节点直接访问这个变量，例如：</p>
<pre><code class="language-gdscript">$&quot;/root/玩家&quot;.移动速度 = 300
</code></pre>
<p>这样就可以修改玩家的移动速度了。</p>
<blockquote>
<p>[!tip]</p>
<p>讲了半天就是说，<code>节点.属性</code> 这种语法也可以引用到咱们自己定义的属性变量。</p>
</blockquote>
<p>现在来实现上图中的效果，我把代码写在了根节点上，滑动条的 <code>value_changed</code> 信号连接的方法如下：</p>
<pre><code class="language-gdscript">func _on_h_slider_value_changed(value):
    $&quot;玩家&quot;.移动速度 = value
    $Label.text = &quot;移动速度：&quot; + str(value)
</code></pre>
<p>同理，我们在节点上定义的方法也可以被上述方式访问：</p>
<pre><code class="language-gdscript">$&quot;/root/玩家&quot;.获取横向移动()
</code></pre>
<h2 id="命名类"><a class="header" href="#命名类">命名类</a></h2>
<p>我说咱的脚本就是类，可我们接触过的类都有一个名字对吧，比如 <code>Input</code> 是类名，<code>LineEdit</code> 是类名，那我们的类是什么名字？</p>
<p>很明显，咱的类目前还没有名字，但我们可以通过 <code>class_name</code> 关键字指定一个名字，只需要在方法外面（与属性同级）的地方写上 <code>class_name &lt;类名&gt;</code> 即可，例如：</p>
<pre><code class="language-gdscript">extends Node2D
class_name 玩家移动控制器

var 移动速度: int = 100

func _physics_process(delta):
    var 移动 := 获取横向移动()
    if 移动 != 0:
        position.x += 移动 * delta * 移动速度

func 获取横向移动() -&gt; int:
    if Input.is_action_pressed(&quot;Left&quot;):
        return -1
    if Input.is_action_pressed(&quot;Right&quot;):
        return 1
    return 0
</code></pre>
<p>拥有类名后就可以与强类型变量使用了，例如 <code>var 玩家: 玩家移动控制器 = $&quot;/root/玩家&quot;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活敌人"><a class="header" href="#整活敌人">整活：敌人</a></h1>
<p>本章节的整活部分将在上一章的结果上，做出这样一个东西：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/game.gif" alt="展示" /></p>
<blockquote>
<p>在这个游戏中，玩家可以切换两种武器攻击敌人，敌人则会一直追着玩家，敌人接触玩家会让玩家受到伤害。</p>
<p>屏幕左上角可以看到玩家的血量和使用的武器。</p>
</blockquote>
<h2 id="敌人节点"><a class="header" href="#敌人节点">敌人节点</a></h2>
<p>本节来实现敌人，敌人作为一个会移动的物体，使用 <code>RigidBody2D</code> 作为根节点：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/game_diren.png" alt="敌人节点" /></p>
<h2 id="敌人移动"><a class="header" href="#敌人移动">敌人移动</a></h2>
<p>敌人的移动逻辑很简单，就是一直向玩家方向跑过去。</p>
<p>所以第一步是需要获取到玩家节点：</p>
<pre><code class="language-gdscript">var 目标:RigidBody2D

func _ready():
    目标 = $&quot;/root/Game/玩家&quot;
</code></pre>
<p>接着，只需要在 <code>_physics_process</code> 方法中不断向玩家移动即可：</p>
<pre><code class="language-gdscript">@export var 移动速度:float = 300

func _physics_process(delta):
    var 移动方向 = (目标.global_position - global_position).normalized()
    move_and_collide(移动方向 * 移动速度 * delta)
</code></pre>
<h2 id="敌人受击"><a class="header" href="#敌人受击">敌人受击</a></h2>
<p>敌人会被玩家用子弹攻击，所以我们可以给敌人定义一个血量变量和一个受到攻击的方法：</p>
<pre><code class="language-gdscript">var 生命值:int = 10

func 受伤(伤害:int):
    生命值 -= 伤害
    if 生命值 &lt;= 0:
        queue_free()
</code></pre>
<p>接着修改子弹的代码：</p>
<pre><code class="language-gdscript">func _on_body_entered(body:PhysicsBody2D):
    # 给敌人节点添加到“敌人”组中。
    if body.is_in_group(&quot;敌人&quot;):
        body.受伤(4) # 对敌人造成 4 点伤害
        queue_free()
</code></pre>
<p>在场景中放几个敌人，运行游戏试试吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="封装"><a class="header" href="#封装">封装</a></h1>
<p>已知，我们可以使用 <code>&lt;节点&gt;.&lt;属性变量&gt;</code> 的方式引用其他节点的属性变量并修改，但这样其实很危险，例如我们可能会不小心把玩家速度设置成负数，或将玩家的生命值设置过大导致超出生命上限。</p>
<p>在传统编程语言中，我们通常会给变量添加对应的访问方法，下例中的 <code>设置移动速度</code> 方法就是一个典型：</p>
<pre><code class="language-gdscript">var 移动速度: int = 100

# 假设玩家最低移动速度是 10
func 设置移动速度(新速度:int):
    if 新速度 &lt; 10:
        新速度 = 10
    移动速度 = 新速度

func 获取移动速度() -&gt; int:
    return 移动速度
</code></pre>
<p>随后，我们只要<em>保证</em>每次用到 <code>移动速度</code> 时都通过调用 <code>设置移动速度</code> 或 <code>获取移动速度</code> 方法即可。</p>
<blockquote>
<p>[!note]</p>
<p>封装除了可以对属性值进行限制，还可以作为属性的唯一访问途径来监听属性值的变化，例如可以在 <code>设置玩家速度</code> 方法中加一个 <code>print(&quot;玩家变速了！&quot; + str(新速度))</code> 来提醒咱们玩家速度发生变化。</p>
</blockquote>
<p>然后问题来了，肯定有一天我们会忘记 <code>移动速度</code> 属性还有两个对应的访问方法，这时候就需要用到 GDScript 为我们提供的 <code>set</code>、<code>get</code> 关键字来指定变量的访问方法了：</p>
<pre><code class="language-gdscript">var 移动速度: int = 100: set = 设置移动速度, get = 获取移动速度
</code></pre>
<p>在变量初始值后面加上了一个冒号，然后写上 <code>set = XXX, get = XXX</code> 这样的东西，这就为移动速度属性指定了两个访问方法。</p>
<p>在我们需要使用 <code>移动速度</code> 变量时，依旧按照普通变量的方式使用即可。就是说当执行 <code>$&quot;玩家&quot;.移动速度 = 400</code> 这句代码时，就会自动调用 <code>设置移动速度</code> 方法并将 400 作为参数传入其中，相应的，执行 <code>print($&quot;玩家&quot;.移动速度)</code> 时，实际输出的就是 <code>获取移动速度</code> 方法的返回值。</p>
<p>其实上例的代码可以简化，因为 <code>获取移动速度</code> 这个访问方法中没有进行任何操作，只是原样返回数值而已，所以可以省略掉这个方法和对应的 <code>get = XXX</code>。</p>
<h2 id="可运行的例子"><a class="header" href="#可运行的例子">可运行的例子：</a></h2>
<pre><code class="language-gdscript">var 属性:int = 10:set = _设置属性, get = _获取属性

func _设置属性(新的值:int):
    if 新的值 &gt; 0:
        属性 = 新的值
    else:
        属性 = 新的值 * 新的值

func _获取属性() -&gt; int:
    if 属性 == 0:
        print(&quot;巧了，属性值竟然是零&quot;)
    return 属性

func _run():
    print(属性)
    属性 = 0
    print(属性)
    属性 = -22
    print(属性)
</code></pre>
<p>如果现在执行 <code>_run</code> 方法，则会看到如下输出：</p>
<pre><code>10
巧了，属性值竟然是零
0
484
</code></pre>
<blockquote>
<p>[!tip]</p>
<p><code>_设置属性</code> 和 <code>_获取属性</code> 方法作为属性的访问方法，咱一般不希望别人随便使用，所以起名字的时候给加上下划线前缀来告诉别人没事别用我。</p>
</blockquote>
<h2 id="简写形式"><a class="header" href="#简写形式">简写形式</a></h2>
<p>每次定义这种 <code>设置xxx</code>、<code>获取xxx</code> 的方法也很麻烦，所以 Godot 给咱提供了一种简便的方式：</p>
<pre><code class="language-gdscript">var 属性 = 100: 
    set(新的值):
        if 新的值 &gt; 0:
            属性 = 新的值
        else:
            属性 = 新的值 * 新的值
    get:
        if 属性 == 0:
            print(&quot;巧了，属性值竟然是零&quot;)
        return 属性
</code></pre>
<p>这段代码与上面<strong>可运行的例子</strong>的逻辑相同，关键语法就是把 <code>set = XXX</code> 这种东西改成了一个类似名为 set 方法的结构，get 同理，但要注意这里不需要 <code>func</code> 关键字。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活玩家生命值"><a class="header" href="#整活玩家生命值">整活：玩家生命值</a></h1>
<p>本节来给玩家加上生命值，当被敌人摸到的时候减血。</p>
<h2 id="玩家代码"><a class="header" href="#玩家代码">玩家代码</a></h2>
<p>首先第一件事是给玩家定义一个生命值属性：</p>
<pre><code class="language-gdscript">var 生命值:int = 100 : 
    set(value):
        生命值 = value
        $&quot;/root/Game/UI/生命值&quot;.value = 生命值
</code></pre>
<blockquote>
<p>此处对 <code>生命值</code> 进行了封装，当设置生命值的时候也会同时修改游戏的 UI。</p>
</blockquote>
<h2 id="生命值-ui"><a class="header" href="#生命值-ui">生命值 UI</a></h2>
<p>生命值 UI 使用了一个 ProgressBar 节点，这个节点会显示一个进度条，并通过 value 属性控制进度条的进度，默认情况下 value 的取值范围是 0 ~ 100，咱默认给它一个 100 即可。</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/game_healthBar.png" alt="生命值UI" /></p>
<blockquote>
<p>别忘了玩家的 <code>生命值</code> 属性有个 set 封装，在封装代码中引用了这个 UI 节点，并在修改 <code>生命值</code> 时修改进度条的值。</p>
</blockquote>
<h2 id="敌人攻击玩家"><a class="header" href="#敌人攻击玩家">敌人攻击玩家</a></h2>
<p>目前的游戏逻辑是，当敌人碰到玩家时，不断对玩家造成 1 点伤害。</p>
<p>回到敌人节点上，敌人的根节点 RigidBody2D 拥有两个信号：<code>body_entered</code> 和 <code>body_exited</code>，这两个信号会在敌人接触到另一个 RigidBody 和离开另一个 RigidBody 时触发，所以下面这段代码可以将“是否碰到玩家”这个值记录在变量 <code>接触玩家</code> 中：</p>
<pre><code class="language-gdscript">var 接触玩家 = false

func _on_body_exited(body:Node):
    if body == 目标:
        接触玩家 = false

func _on_body_entered(body:Node):
    if body == 目标:
        接触玩家 = true
</code></pre>
<p>接着，在敌人的 <code>_physics_process</code> 方法中，根据 <code>接触玩家</code> 变量来对玩家造成伤害即可：</p>
<pre><code class="language-gdscript">if 接触玩家:
    目标.生命值 -= 1
</code></pre>
<h2 id="rigidbody2d-节点设置"><a class="header" href="#rigidbody2d-节点设置">RigidBody2D 节点设置</a></h2>
<p>此时如果运行游戏，其实并不会有攻击效果，此处还需要对敌人的 RigidBody2D 节点做下设置：</p>
<ol>
<li>
<p>启用 Contact Monitor 属性</p>
</li>
<li>
<p>修改 Max Contacts Reported 使其大于 0，此处我用了 10。</p>
</li>
</ol>
<blockquote>
<p>其中 Contact Monitor 属性控制了能否触发 <code>body_entered</code> 和 <code>body_exited</code> 信号。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="继承"><a class="header" href="#继承">继承</a></h1>
<p>继承，放到三次元就是说长辈的东西留给子辈，在编程中的继承也差不多。</p>
<p>请再回忆起之前讲解面向对象时用过的例子：手机。</p>
<p>我们当时说过，手机有颜色、电量这些属性，还有开机、打电话这种方法，用我们现有的知识，我们可以把手机写成下面这种类：</p>
<pre><code class="language-gdscript">class_name 手机

# 默认是个黑色的手机，后面的三个零分别代表红绿蓝三色值，范围是 0 到 1
var 颜色: Color = Color(0, 0, 0)

# 默认满电，且电量变量取值范围是 0 ~ 100
var 电量: int = 100 : 
    set(新电量):
        if 新电量 &gt; 100: 新电量 = 100
        elif 新电量 &lt; 0: 新电量 = 0
        电量 = 新电量

var 已经开机 := false

func 开机():
    print(&quot;加载中...&quot;)
    已经开机 = true
    print(&quot;开机完成&quot;)

func 打电话(电话号码:String):
    if 已经开机:
        print(&quot;给 &quot; + 电话号码 + &quot; 打了电话&quot;)
</code></pre>
<p>这个手机挺好用的，能开机能打电话，但是某天国外一小伙敲不死推出了一款新手机，竟然能发短信：</p>
<pre><code class="language-gdscript">func 发短信(电话号码:String, 短信内容:String):
    if 已经开机:
        print(&quot;给 &quot; + 电话号码 + &quot; 发信息，内容如下：&quot; + 短信内容)
</code></pre>
<p>直接添加这个方法会导致每个手机实例都支持发短信方法，然而实际上，并不是每款手机都能发短信，因此，我们需要区分这个手机实例是老款手机还是新款手机。目前这样简单的功能我们可以添加一个属性来表示手机型号，并在新功能中判断该手机是否是新型，但如果新功能很多，这样的粗暴解决方式就不太好用了。最终的解决方案是，我们希望游戏中有两个类，一个是手机类，能发短信，另一个也是手机类，但<strong>不能</strong>发短信。</p>
<p>如果你是个勤劳者，现在只需要把上面代码复制一遍，再写一个包含 <code>发短信</code> 方法的新手机类即可，这样我们的游戏中就拥有了两种手机。</p>
<p>不过，历史上那些创造编程语言的人可能并不勤劳，但好在他们都很聪明，为了不写重复的代码，他们发明了继承机制，可以<strong>在某个类的基础上作出修改以创造新的类</strong>，这种情况下，我们把原有的类称为 <strong>基类</strong> 或 <strong>父类</strong>，修改出来的新的类称为 <strong>派生类</strong> 或 <strong>子类</strong>。</p>
<blockquote>
<p>偷懒是进步的阶梯，我们从来不写重复的代码。</p>
</blockquote>
<p>继承的核心思想就是把父类的东西传承给子类，也就是说，父类有的东西子类也都有，但子类有的父类不一定有。上面的手机就是很好的例子，老款手机就是父类，新款手机就是子类，老手机能做的事情新手机也都能做，但新手机能发短信，老手机则不行。</p>
<p>现在我们动手来写新手机：</p>
<pre><code class="language-gdscript">extends 手机
class_name 能发短信的手机

func 发短信(电话号码:String, 短信内容:String):
    if 已经开机:
        print(&quot;给 &quot; + 电话号码 + &quot; 发信息，内容如下：&quot; + 短信内容)
</code></pre>
<p>ok，很简单就写完了，我们使用一个 <code>extends</code> 关键字指定了当前类的父类，也就是告诉 GDScript 当前类是根据 <code>手机</code> 类修改而来，因此我们不用再次书写颜色、电量等属性或方法，只需要添加新功能即可。</p>
<blockquote>
<p>[!note]</p>
<p>GDScript 仅支持单继承，就是说子类只能继承自一个父类。</p>
<p>不过，父类还可能继承自另一个父类（爷爷类），所以继承关系可以形成一条长链。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="节点与继承"><a class="header" href="#节点与继承">节点与继承</a></h1>
<p>每次添加新节点，都能看到这样的界面：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/nodes.png" alt="节点继承关系" /></p>
<p>这些节点类型之间呈现出一种树状结构，层层递进，这样布局是怎么来的呢？</p>
<p>我们用 Button 节点举例，它的完整位置在 <code>Node -&gt; CanvasItem -&gt; Control -&gt; BaseButton -&gt; Button</code> ，开头的 Node 表示这是个节点，CanvasItem 表示这是一个 2D 绘制节点，Control 表示 UI 节点，然后就是 Button 按钮节点。</p>
<p>现在添加一个 Button 到场景中，我们能看到它的属性列表如下：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/button.png" alt="Button 的属性" /></p>
<p>从上向下，我们会发现这些属性分成了 Button、BaseButton、Control、CanvasItem、Node 这几组，很明显这就是 Button 节点在节点列表中的路径倒序。</p>
<p>结合本节标题，你应该也猜到了，Button 类正是继承自这些父类节点而来，所以我们可以在 Button 节点上看到 Control、Node 等父类的属性。同理，其他节点也相同。</p>
<h2 id="脚本的继承"><a class="header" href="#脚本的继承">脚本的继承</a></h2>
<p>思考我们曾经写过的代码：<code>position.x += 10</code>，这里的 position 属性来自哪里呢？没错，就是继承自父类的。</p>
<p>每个脚本的开头，Godot 都会给我们生成一行继承语句，继承的父类通常是脚本所绑定到的节点类型。</p>
<p>根据所学，继承可以给原有的类增加功能，所以当我们的脚本继承自某个节点类时，我们<strong>实际上就是在一种节点的基础上创造了一种新的节点</strong>，并添加了我们的功能，例如玩家移动等效果。</p>
<blockquote>
<p>[!tip]</p>
<p>我们的脚本并不一定需要继承自这个节点本身的类型，也可以是它的父类，例如我们只是希望调整按钮的位置，那么我们可以继承 Control 类，这样这个调整位置的脚本就可以用在所有 Control 的子类类型的节点上。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重写"><a class="header" href="#重写">重写</a></h1>
<p>又一个新要求来了，之前那个能发短信的手机，为了显得与众不同，他们决定定制一个开机画面。</p>
<p>现在，全游戏的手机在开机时都会显示两句话：</p>
<pre><code>加载中...
开机完成
</code></pre>
<p>因为所有手机的开机方法都是相同的：</p>
<pre><code class="language-gdscript">func 开机():
    print(&quot;加载中...&quot;)
    已经开机 = true
    print(&quot;开机完成&quot;)
</code></pre>
<p>为了展示那个定制化开机画面，我们可以写一个新的 <code>开机2.0</code> 方法。不过，当一个外人拿到手机时，他可能会错误的使用老开机方法，导致没能看到炫酷的新开机画面，因此我们要做的不是加方法，而是<strong>改方法</strong>。</p>
<p>重写是面向对象中一个重要的功能，它可以让我们在子类中覆盖父类的方法，从而实现方法名一样但效果不同的效果。</p>
<p>现在，来到我们的新手机类中，添加如下代码：</p>
<pre><code class="language-gdscript">func 开机():
    print(&quot;嘟-嘟-嘟-.-.-.-&quot;)
    已经开机 = true
    print(&quot;Hello!&quot;)
</code></pre>
<p>我们又一次声明了开机方法，这与父类中的开机方法重名，这，就构成了重写，也就是子类的这个开机方法覆盖了父类的开机方法。</p>
<p>现在，当一个人拿到手机时，不论手机是什么型号，只要他开机，即可根据手机型号显示不同的开机画面。</p>
<h2 id="子类调用父类"><a class="header" href="#子类调用父类">子类调用父类</a></h2>
<p>现在，这个新手机想要大力推广短信功能，它们决定在每次打电话前都显示一句“为什么不试试发短信呢？”这样的广告语。</p>
<p>为了达成这个目标，我们不希望完全覆盖父类的方法，而是希望在父类方法前或后添加自己的代码，这时候，我们可以在代码中使用 <code>super</code> 关键字引用父类实例并从中调用方法：</p>
<pre><code class="language-gdscript"># 在子类中
func 打电话(电话号码:String):
    print(&quot;为什么不试试发短信呢？&quot;)

    # 调用父类的打电话方法
    super.打电话(电话号码)
</code></pre>
<p>现在，新手机在打电话时，会先显示那句广告，然后执行父类的打电话方法。</p>
<blockquote>
<p>[!tip] 生命周期方法</p>
<p>其实那些 _ready、_process 等生命周期方法也是重写的父类方法。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多态"><a class="header" href="#多态">多态</a></h1>
<p>多态，就是说多种形态。</p>
<p>例如在之前的手机例子中，手机就拥有多种形态，一种形态能发短信，另一种形态不能发短信。但总的来说，它们都属于手机，它们都具备手机共有的功能：开机和打电话。</p>
<p>在代码中，我们可以把子类实例存放到父类类型的变量中，并且可以根据父类中的成员名称访问子类的成员：</p>
<pre><code class="language-gdscript">var 某人的手机:手机 = 新手机.new()

某人的手机.打电话(&quot;10086&quot;)   
# 虽然 某人的手机 是手机类型，但其值是新手机，所以调用的是新手机的打电话方法。

# 某人的手机.发短信(&quot;10086&quot;,&quot;Hello&quot;)
# 上面这句注释掉的代码是错误的。
# 虽然新手机能发短信，但是 某人的手机 是老手机类型，不包含发短信方法。
</code></pre>
<blockquote>
<p>[!note]</p>
<p><code>新手机.new()</code> 的意思是实例化一个新手机，就是创造一个新手机实例的意思。</p>
</blockquote>
<p>例如我现在拥有三台手机：</p>
<pre><code class="language-gdscript">var 手机们 := [
    手机.new(),
    新手机.new(),
    手机.new(),
]
</code></pre>
<p>这三台手机都存放在了数组中，现在我想给它们都开机：</p>
<pre><code class="language-gdscript">for 手机之一 in 手机们:
    手机之一.开机()
</code></pre>
<p>在这段开机的遍历代码中，我们并不在乎手机是新手机还是老手机，我们只管调用它的开机方法即可，此时的 <code>手机之一</code> 变量就是具有多种形态的。</p>
<p>当然，使用多态的目的不是让我们的变量变得花里胡哨，而是规范一类操作，在刚才的例子中，我们就规范了所有手机的开机方式都应该使用 <code>开机</code> 方法，最终的作用就是实现了这一句话：<strong>不在乎手机是新手机还是老手机，我们只管调用它的开机方法</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活多种武器"><a class="header" href="#整活多种武器">整活：多种武器</a></h1>
<p>本节来实现玩家切换武器。</p>
<p>回顾目前玩家发射子弹时的代码，是这样写的：</p>
<pre><code class="language-gdscript">func _process(delta):
    if Input.is_action_just_pressed(&quot;攻击&quot;):
        var 创建的子弹:子弹类 = 子弹.instantiate()
        创建的子弹.移动速度 = 鼠标方向.normalized() * 1000
        $&quot;/root/&quot;.add_child(创建的子弹)
        创建的子弹.global_position = global_position
        创建的子弹.rotation = 鼠标方向.angle()
</code></pre>
<p>这段代码写在了玩家节点上，此时我们为了能让玩家切换武器，可以来制作一个新的节点，用来表示武器，并将发射子弹的代码写在武器中。</p>
<h2 id="武器节点"><a class="header" href="#武器节点">武器节点</a></h2>
<p>由于咱们的武器不会显示出来，所以武器节点其实就是一个 Node 节点，不需要其他东西，重点内容在 Node 节点的代码上。</p>
<p>当然如果你希望给玩家的武器显示一些图片，也可以在这个武器节点中添加一些 Sprite2D 节点。</p>
<h2 id="武器节点的代码"><a class="header" href="#武器节点的代码">武器节点的代码</a></h2>
<pre><code class="language-gdscript">extends Node2D
class_name 武器

@export var 子弹: PackedScene

func 开火(dir:float):
    pass
</code></pre>
<p>这里，我们定义了一个开火方法，并需要指定一个参数来表示开火的方向，但是这个方法内部我们什么都没写。</p>
<p>此时当我们要添加一种新武器时，即可让新武器类继承这个武器类，并重写其中的 <code>开火</code> 方法，在新的开火方法中创建子弹即可。</p>
<p>例如现在创建 <code>步枪</code> 类：</p>
<pre><code class="language-gdscript">extends 武器

func 开火(dir:float):
    var zd:子弹类 = 子弹.instantiate()
    zd.global_position = global_position
    zd.rotation = dir
    $&quot;/root/Game&quot;.add_child(zd)
    zd.移动速度 = Vector2.from_angle(dir) * 1000
</code></pre>
<p>和 <code>霰弹枪</code> 类：</p>
<pre><code class="language-gdscript">extends 武器

func 开火(dir:float):
    创建子弹(dir - 0.6)
    创建子弹(dir - 0.3)
    创建子弹(dir)
    创建子弹(dir + 0.3)
    创建子弹(dir + 0.6)

func 创建子弹(dir:float):
    var zd:子弹类 = 子弹.instantiate()
    zd.global_position = global_position
    zd.rotation = dir
    $&quot;/root/Game&quot;.add_child(zd)
    zd.移动速度 = Vector2.from_angle(dir) * 400
</code></pre>
<p>接着我们再创建两个 <code>步枪</code> 和 <code>霰弹枪</code> 的 PackedScene，并在其节点上挂在上面两个脚本，然后在玩家切换武器时实例化这两个 PackedScene 即可：</p>
<pre><code class="language-gdscript">func _process(delta):
    if Input.is_action_just_pressed(&quot;武器1&quot;):
            切换武器(load(&quot;res://武器/步枪.tscn&quot;))
        if Input.is_action_just_pressed(&quot;武器2&quot;):
            切换武器(load(&quot;res://武器/霰弹.tscn&quot;))

func 切换武器(武器:PackedScene):
    $&quot;武器&quot;.free()
    var wq = 武器.instantiate()
    add_child(wq)
    wq.position = Vector2(0, 0)
    wq.name = &quot;武器&quot;
</code></pre>
<p>接着即可修改玩家的开火代码：</p>
<pre><code class="language-gdscript">if Input.is_action_just_pressed(&quot;攻击&quot;):
    $&quot;武器&quot;.开火(rotation)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号-1"><a class="header" href="#信号-1">信号</a></h1>
<p>信号这个东西我相信大家已经能够熟练运用了，但我们一直都在使用 Godot 节点给我们提供的信号。现在我们要定义我们自己的信号了。</p>
<p>信号类似属性和方法，也属于类成员，在脚本中使用 <code>signal</code> 关键字定义信号，具体格式和定义方法差不多：</p>
<pre><code>signal &lt;信号名&gt;([参数列表])
</code></pre>
<p>例如我们给手机类定义一个 <code>开机完成</code> 方法：</p>
<pre><code class="language-gdscript">signal 开机完成()
</code></pre>
<p>然后把手机脚本放到节点上，就能在这个节点的列表中看到这个信号了：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/mySignal.png" alt="开机完成 信号" /></p>
<h2 id="触发信号"><a class="header" href="#触发信号">触发信号</a></h2>
<p>信号需要手动触发，使用 <code>emit</code> 方法：</p>
<pre><code class="language-gdscript">func 开机():
    print(&quot;加载中...&quot;)
    已经开机 = true
    print(&quot;开机完成&quot;)
    开机完成.emit()
</code></pre>
<h2 id="带参数的信号"><a class="header" href="#带参数的信号">带参数的信号</a></h2>
<p>例如咱们再做一个发送短信的信号：</p>
<pre><code class="language-gdscript">signal 发送短信完成(目标号码:String, 短信内容:String)

func 发短信(电话号码:String, 短信内容:String):
    if 已经开机:
        print(&quot;给 &quot; + 电话号码 + &quot; 发信息，内容如下：&quot; + 短信内容)
        发送短信完成.emit(电话号码, 短信内容)
</code></pre>
<blockquote>
<p>[!note] 不可滥用信号</p>
<p>信号可以向外界反应自身的状态，但这不是节点之间的唯一通信途径，别忘了我们可以直接使用 <code>&lt;节点变量&gt;.属性或方法</code> 这种形式修改其他节点的属性或是调用其他节点的方法。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整活更换武器的ui提示"><a class="header" href="#整活更换武器的ui提示">整活：更换武器的UI提示</a></h1>
<p>首先先加一个 Label 节点来显示玩家当前的武器：</p>
<p><img src="Part-%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/./images/game_label.png" alt="武器Label" /></p>
<h2 id="玩家的代码"><a class="header" href="#玩家的代码">玩家的代码</a></h2>
<p>首先，我们给玩家的定义一个切换武器信号：</p>
<pre><code class="language-gdscript">signal 更换武器(武器名:String)
</code></pre>
<p>并在切换武器时触发这个信号：</p>
<pre><code class="language-gdscript">if Input.is_action_just_pressed(&quot;武器1&quot;):
    切换武器(load(&quot;res://武器/步枪.tscn&quot;))
    更换武器.emit(&quot;步枪&quot;)
if Input.is_action_just_pressed(&quot;武器2&quot;):
    切换武器(load(&quot;res://武器/霰弹.tscn&quot;))
    更换武器.emit(&quot;霰弹&quot;)
</code></pre>
<p>接着我们就可以给这个显示武器的 Label 添加上这样的脚本：</p>
<pre><code class="language-gdscript">extends Label

func _ready():
    $&quot;/root/Game/玩家&quot;.更换武器.connect(修改武器名)

func 修改武器名(名称):
    text = &quot;当前武器：&quot; + name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进阶技巧"><a class="header" href="#进阶技巧">进阶技巧</a></h1>
<p>掌握前几章的内容就已经可以实现很多游戏效果了，再继续学习一些引擎和节点的知识，就能实现绝大多数的游戏功能。</p>
<p>但就像其他技能一样，掌握使用方法只是一个开始。如果你的工程稍微复杂些，下面这些内容将让你编写出更高质量的代码。</p>
<blockquote>
<p>编写的代码不仅要保证能用，还要保证能读懂，且容易修改和添加新功能。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>有时我们需要存储“有限数值”中的某一个值，例如角色的职业、元素的属性等。</p>
<p>此处用“星期”来举例子：<code>var 今天是周几 = &quot;星期一&quot;</code>，此时当另一个人接手这个项目，或是你摸鱼许久再来填坑，可能不小心写了这样一行代码：<code>if 今天是周几 == &quot;周一&quot;:</code>，在你的脑海中这是正确的，但在计算机眼里 <code>&quot;星期一&quot;</code> 和 <code>&quot;周一&quot;</code> 是两个完全不同的值，所以这个 if 语句的条件永远不会满足。</p>
<p>此时最简单的办法就是告知参与项目的所有人，规定 <code>今天是周几</code> 变量的值只能存放 <code>&quot;星期几&quot;</code>，而不能写 周几 或 礼拜几。</p>
<p>但就像我在封装那一节说过的，总有一天这种规矩会被忘掉，所以我们干脆定义一种新的类型吧，就叫它 <code>星期</code> 类型：</p>
<pre><code class="language-gdscript">enum 星期 {
    星期一,
    星期二,
    星期三,
    星期四,
    星期五,
    星期六,
    星期日,
}
</code></pre>
<p>上面这种语法就是在定义<strong>枚举</strong>，使用 <code>enum</code> 关键字表示定义枚举的开始，然后紧跟枚举的名称，此处枚举名是 <code>星期</code>，接着一对花括号，括号内部填写枚举的值，并用逗号分隔。（最后一个值后的逗号是可选的）</p>
<p>接下来结合强类型语法即可修改之前的 <code>今天是周几</code> 变量：</p>
<pre><code class="language-gdscript">var 今天是周几: 星期 = 星期.星期一
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>枚举的定义位置应该在代码文件的最外层，不能在方法里定义枚举。</p>
</blockquote>
<p>在游戏中枚举的用法例子：</p>
<pre><code class="language-gdscript">enum 职业 {
    战士, 法师, 射手
}
enum 属性 {
    火, 水, 电,
}
</code></pre>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>有时候我们需要一些不需要改变或不能改变的量，也就是常量，例如数学中的 π （3.14159）作为一个不变的数字，我们就可以把它存放在常亮中。</p>
<blockquote>
<p>当然圆周率这种常用的东西，Godot 已经给咱们存好了，这个常量叫做 <code>PI</code></p>
</blockquote>
<p>常量使用 const 关键字定义，语法格式与变量相同：</p>
<pre><code>const &lt;常量名&gt; = &lt;值&gt;
</code></pre>
<p>由于常量不允许被修改，所以在定义时必须给它一个值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单例自动加载"><a class="header" href="#单例自动加载">单例/自动加载</a></h1>
<p>我们的游戏经常需要有个地方存放一些全局性的信息，例如游戏的版本、当前游戏时间等，通常我们会单独制作一个节点来存放这些信息。</p>
<p>这就引出了一个问题，这个全局信息节点由谁来创建呢？首先排除手动创建，大家心里要明白当 Godot 自己不出问题时最容易出问题的东西就是人，所以 Godot 给咱提供了自动创建功能。</p>
<p>现在打开菜单栏中【项目】【项目设置】界面，点击其中的【自动加载】选项卡即可看到：</p>
<p><img src="Part-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/./images/autoload.png" alt="自动加载界面" /></p>
<p>在最上面的路径中填写需要被加载的 PackedScene 路径或点击后面的文件夹按钮来选择一个 PackedScene 后，再给它起个名字即可点击最后的添加按钮：</p>
<p><img src="Part-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/./images/add_autoload.png" alt="添加自动加载" /></p>
<p>同时注意自动加载列表中有一个全局变量按钮，当勾选了这个东西时即可在代码中的任意位置通过前面的名称使用这个节点或脚本的实例，例如现在在任意代码处即可使用：</p>
<pre><code class="language-gdscript">print(player.global_position)
</code></pre>
<blockquote>
<p>如果你学过其他编程语言中的设计模式，就会明白“自动加载”就是起到了单例模式的作用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="唯一名称"><a class="header" href="#唯一名称">唯一名称</a></h1>
<p>某些节点需要在其他位置反复通过 <code>$&quot;XXX&quot;</code> 语法访问，这时候 $ 符号后面长长的路径就会成为累赘。</p>
<p>如果这个节点的名称在场景中是唯一的，那么就可以给这个节点勾选上 唯一名称：</p>
<p><img src="Part-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/./images/name.png" alt="唯一名称的位置" /></p>
<p>此时即可在代码中通过 <code>%&quot;节点的唯一名称&quot;</code> 语法来获取这个节点，在这种语法中就只填写节点名即可，不需要节点的路径。</p>
<blockquote>
<p>如果节点名称没有空格或者其他特殊符号、没有造成语法歧义的话，可以去除引号，也就是 <code>%节点的唯一名称</code>。</p>
</blockquote>
<blockquote>
<p>[!note]</p>
<p>注意，不是不重名就可以用 % 符号获取，一定不要忘记给节点标记上 唯一名称。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load"><a class="header" href="#load">load</a></h1>
<p>之前在学习 PackedScene 的时候用过 load 方法，知道它可以从文件中读取一个 PackedScene。</p>
<p>但实际上，load 方法可以读取任何 Godot 认识的文件，例如脚本、图片、声音以及PackedScene等等。</p>
<p>例如加载图片并显示在 TextureRect 节点上：</p>
<pre><code class="language-gdscript">$&quot;TextureRect&quot;.texture = load(&quot;res://你的图片路径&quot;)
</code></pre>
<p>或者加载一段声音并播放：</p>
<pre><code class="language-gdscript">$&quot;AudioStreamPlayer&quot;.stream = load(&quot;res://你的音频路径&quot;)
$&quot;AudioStreamPlayer&quot;.play()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义类"><a class="header" href="#定义类">定义类</a></h1>
<p>我们已经感受到了，在 Godot 中，一个 GDScript 脚本文件就是一个类，但某些情况下，我们需要一些小巧的类，我们懒得去再创建一个新的脚本文件了，此时就可以用内部类语法：</p>
<pre><code>class &lt;类名&gt;:
    &lt;类成员（方法、属性、信号等）&gt;
</code></pre>
<p>例如我们用这种形式定义一个 伤害来源 类：</p>
<pre><code class="language-gdscript">class 伤害来源:
    var 攻击者 = null
    var 伤害值 = 0
    var 是魔法吗 = false
</code></pre>
<p>可见，除开第一行 class 关键字外，其他的语法都正常的类相同。</p>
<p>但注意，这样定义的类被称作内部类，就是说这个伤害来源类是位于当前脚本文件类内部的类，所以外部脚本想要使用这个伤害来源类时，就需要使用 <code>外部类.内部类</code> 的形式来访问。</p>
<p>假设刚刚定义 伤害来源 类的文件中有一行 <code>class_name 伤害相关</code>，那么外部代码在使用 伤害来源 类时则需要：</p>
<pre><code class="language-gdscript">var 伤害 = 伤害相关.伤害来源.new() # 实例化这个类
</code></pre>
<blockquote>
<p>[!note] 非节点的类实例</p>
<p>上面的 <code>伤害来源</code> 例子中，这个类就没继承自任何一个节点父类，也就是说 <code>伤害来源</code> 并不是一种节点，当实例化了这个类时，游戏中确实会多出一个 <code>伤害来源</code> 实例，但这个实例不会对游戏产生直接影响，它的属性和方法仅供我们其它代码使用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型判断"><a class="header" href="#类型判断">类型判断</a></h1>
<p>有时候我们需要判断一个实例是否是某个类的实例，此时可以使用 is 关键字。</p>
<p>例如，判断进入碰撞范围的节点是否是敌人：</p>
<pre><code class="language-gdscript">func _on_body_entered(body):
    if body is 敌人:
        print(&quot;敌人进来了&quot;)
    else:
        print(&quot;进来的不是敌人&quot;)
</code></pre>
<p>其中，<code>body is 敌人</code> 会在 body 为敌人类或敌人子类的实例时得到 true，否则为 false。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="静态"><a class="header" href="#静态">静态</a></h1>
<p>有时候我们需要定义一些“工具方法”，例如获取两个敌人中生命值较高的那一个：</p>
<pre><code class="language-gdscript">func 获取生命值高(敌人1, 敌人2):
    if 敌人1.生命值 &gt; 敌人2.生命值:
        return 敌人1
    return 敌人2
</code></pre>
<p>这样的方法只能在当前这个脚本中使用，其他脚本如果想用，就需要先获取上述代码所在脚本的实例，这明显会很麻烦。</p>
<p>回想我们之前使用过的方法 <code>Input.get_action_strength</code>，我们就直接通过 <code>Input</code> 这个类名使用了里面的方法，这种方法被称为<strong>静态方法</strong>，在 GDScript 中使用 <code>static</code> 关键字标注：</p>
<pre><code class="language-gdscript">static func 获取生命值高(敌人1, 敌人2):
    if 敌人1.生命值 &gt; 敌人2.生命值:
        return 敌人1
    return 敌人2
</code></pre>
<p>这样，如果上面代码所在的文件中定义了类名 <code>class_name 工具</code>，即可在任意代码处使用 <code>工具.获取生命值高</code> 来调用这个方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串格式化"><a class="header" href="#字符串格式化">字符串格式化</a></h1>
<p>我们经常需要给玩家显示一些文字，例如向玩家发送一条消息：<code>获得了 10 点经验，你升到了 101 级！</code>：</p>
<pre><code class="language-gdscript">var 经验 := 10
var 等级 := 101
发消息(&quot;获得了 &quot; + str(经验) + &quot; 点经验，你升到了 &quot; + str(等级) + &quot;  级！&quot;)
</code></pre>
<p>其中的发消息函数的参数看起来是在太丑了，这种中文与代码混合的形式简直不是给人看的。Godot 为了咱不被恶心到，提供了一种格式化字符串的语法：</p>
<pre><code>&lt;模版字符串&gt; % &lt;填入值&gt;
</code></pre>
<p>我们现在修改上面的发消息方法：</p>
<pre><code class="language-gdscript">发消息(&quot;获得了 %d 点经验，你升到了 %d 级！&quot; % [经验, 等级])
</code></pre>
<p>前面字符串中的 <code>%d</code> 我们称之为<strong>占位符</strong>，此处会被替换成百分号后面的内容，上例中，<code>经验</code>变量的值填入到了第一个 <code>%d</code> 的位置，<code>等级</code>变量的值填入到了第二个 <code>%d</code> 的位置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存档与读档"><a class="header" href="#存档与读档">存档与读档</a></h1>
<p>Godot 拥有对 Json 数据的完美支持，如果你学习过 Json，可以尝试使用 Json 保存游戏存档。</p>
<p>但面对零基础的新人，我会介绍一种纯 Godot 的数据保存方式。</p>
<h2 id="元数据"><a class="header" href="#元数据">元数据</a></h2>
<p>我们在场景编辑器中，选中任意一个节点后，即可在引擎最右边看到属性面板，这个面板最下面有一个“添加元数据”按钮：</p>
<p><img src="Part-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/./images/metadata.png" alt="添加源数据按钮" /></p>
<p>所谓的元数据，你可以理解成给节点添加一些额外的信息，这些信息类似属性，也是由名称和值来表示的，点击添加元数据按钮后，即可看到一个元数据设置节点，只要在这里填入数据名和值的类型即可，例如咱们现在来存储一下玩家的分数：</p>
<p><img src="Part-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7/./images/metadata_fenshu.png" alt="元数据存储分数" /></p>
<blockquote>
<p>截止至 4.0.1 版本，元数据名称不支持中文。</p>
</blockquote>
<p>点击添加后，在属性列表的最下方即可看到这个分数字段，并且可以修改数值。</p>
<h2 id="打包节点"><a class="header" href="#打包节点">打包节点</a></h2>
<p>本节讲的是存档，为什么我要先讲元数据呢，因为咱们 Godot 给咱提供了一种方法，可以将一个节点保存成文件，这个文件中自然也就包含元数据。</p>
<p>保存节点其实很简单，本质上就是利用了 PackedScene，不过我们之前都是通过 load 方法或 @export 属性来获取项目中已经存在的 PackedScene，而现在，咱们要凭空创造一个 PackedScene。</p>
<p>创造 PackedScene 很简单，只需要先实例化一个 PackedScene 实例，并调用它的 pack 方法即可：</p>
<pre><code class="language-gdscript">var 打包包 := PackedScene.new()
打包包.pack(被打包的节点)
</code></pre>
<p>这个 pack 方法就是将某个节点放到这个 PackedScene 中，所以结合上面的节点元数据，我们就能把分数信息保存到一个 PackedScene 中了：</p>
<pre><code class="language-gdscript">var 节点 := Node.new()
# set_meta 就是添加一条元数据
节点.set_meta(&quot;分数&quot;, 123)

var 打包包 := PackedScene.new()
打包包.pack(节点)
</code></pre>
<blockquote>
<p>[!tip] 不需要 add_child</p>
<p>此处的 Node 节点只是存个数据，不需要添加到场景中去。</p>
</blockquote>
<h2 id="保存资源"><a class="header" href="#保存资源">保存资源</a></h2>
<p>接下来只剩下最后一步了，只要将 PackedScene 保存成文件即可，这需要使用 <code>ResourceSaver.save</code> 方法：</p>
<pre><code class="language-gdscript">ResourceSaver.save(打包包, &quot;user://存档.tscn&quot;)
</code></pre>
<p>这样，那个包含分数元数据的Node就被以 PackedScene 的方式保存到用户目录的 存档.tscn 文件中了。</p>
<p>完整的代码如下：</p>
<pre><code class="language-gdscript">var 节点 := Node.new()
# set_meta 就是添加一条元数据
节点.set_meta(&quot;分数&quot;, 123)

var 打包包 := PackedScene.new()
打包包.pack(节点)

ResourceSaver.save(打包包, &quot;user://存档.tscn&quot;)

# 删除这个用完了的节点
节点.free()
</code></pre>
<blockquote>
<p>[!warning] 不要保存引用</p>
<p>不要保存任何实例的引用，在读取时这些引用都会失效。</p>
<p>建议只保存值类型数据，例如 数字、字符串、Vector3、Color 等。</p>
</blockquote>
<h2 id="读取存档"><a class="header" href="#读取存档">读取存档</a></h2>
<p>因为咱们保存的是个 PackedScene，所以读取存档就是实例化 PackedScene：</p>
<pre><code class="language-gdscript">var 节点 = load(&quot;user://存档.tscn&quot;).instantiate()
# 显示之前保存的分数
print(节点.get_meta(&quot;分数&quot;))
节点.free()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<p>我们的变量可以存数字、字符串、节点实例等各种东西，现在，咱们试试在变量中存放方法。</p>
<p>此处所说的方法，就是咱们一直使用的，使用 <code>func</code> 关键字定义的方法，函数式编程允许我们在变量中存放一个方法的引用，并可通过这个变量调用对应的方法。</p>
<pre><code class="language-gdscript">func _ready():
    var f = A
    f.call() # 输出 123

func A():
    print(&quot;123&quot;)
func B():
    print(&quot;666&quot;)
</code></pre>
<p>同时我们也可以简写，直接将方法定义到变量中，而不用定义新的方法：</p>
<pre><code class="language-gdscript">var hello = func():
    print(&quot;Hello&quot;)
hello.call()
</code></pre>
<p>这种写法一般称为 Lambda 表达式，或者匿名方法。</p>
<p>注意，调用变量中的方法必须要使用 <code>.call</code>，如果方法有参数，则填入到 <code>call</code> 方法的参数中即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="还没整理的内容"><a class="header" href="#还没整理的内容">还没整理的内容</a></h1>
<h2 id="find_child"><a class="header" href="#find_child">find_child</a></h2>
<p>find_child 方法类似 find_path，不过它的参数是节点名而不是路径。</p>
<p>从名字可以看出，find 是寻找，可以理解成搜索节点，搜索范围是全部的子节点。</p>
<p>所以我们可以用 find_child 来获取藏在子节点内部甚至子子子节点中的某个节点。</p>
<p>节点名参数还可以使用 <code>*</code> 和 <code>?</code> 这种通配符，具体使用方式可以看文档。</p>
<p>还可以了解一下 find_children 方法，可以获取多个节点。</p>
<h2 id="遍历子节点"><a class="header" href="#遍历子节点">遍历子节点</a></h2>
<p><code>get_child_count</code> 可以获取当前节点的子节点个数。</p>
<p><code>get_child</code> 可以根据下标获取一个子节点。</p>
<p>结合 for 语句可以遍历全部子节点：</p>
<pre><code class="language-gdscript">for i in range(get_child_count()):
    print(get_child(i))
</code></pre>
<h2 id="字符串操作"><a class="header" href="#字符串操作">字符串操作</a></h2>
<p>查找位置、切割字符串</p>
<h2 id="节点锁定"><a class="header" href="#节点锁定">节点锁定？？？</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/js/style.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
